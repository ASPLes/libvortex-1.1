/**
 * C client stub to invoke services exported by the XML-RPC component: test.
 *
 * This file was generated by xml-rpc-gen tool, from Vortex Library
 * project.
 *
 * Vortex Library homepage: http://vortex.aspl.es
 * Axl Library homepage: http://xml.aspl.es
 * Advanced Software Production Line: http://www.aspl.es
 */
#include <test_types.h>

/* opaque definition */
struct __ItemArray {
	Item ** array;
	int count;
};

XmlRpcArray    * test_itemarray_marshall   (VortexCtx * _ctx_, ItemArray * ref, axl_bool  dealloc)
{
	/* array and method value */
	XmlRpcArray * _result;
	XmlRpcMethodValue * _array_value;

	/* iterator */
	int  iterator = 0;

	/* access variables */
	Item * _value;
	XmlRpcStruct * _struct;

	if (ref == NULL)
		return NULL;

	/* create the XmlRpcArray */
	_result = vortex_xml_rpc_array_new (ref->count);

	while (iterator < ref->count) {
		/* get the array value */
		_value = ref->array[iterator];

		/* translate the value */
		_struct = test_item_marshall (_ctx_, _value, axl_false);
		_array_value = method_value_new (_ctx_, XML_RPC_STRUCT_VALUE, _struct);

		/* add the value to the array */
		vortex_xml_rpc_array_add (_result, _array_value);

		/* update the iterator */
		iterator++;
	}

	/* dealloc the ItemArray reference */
	if (dealloc)
		test_itemarray_free (ref);

	/* return the array created */
	return _result;
}

ItemArray * test_itemarray_unmarshall (XmlRpcArray * ref, axl_bool  dealloc)
{
	ItemArray * _result;
	Item * _value;
	XmlRpcStruct * _rpc_value;
	XmlRpcMethodValue * _array_value;
	int  iterator = 0;

	if (ref == NULL)
		return NULL;

	/* create the array */
	_result = test_itemarray_new (vortex_xml_rpc_array_count (ref));

	while (iterator < _result->count) {
		/* get the method value inside */
		_array_value = vortex_xml_rpc_array_get (ref, iterator);

		/* translate the value */
		_rpc_value = method_value_get_as_struct (_array_value);
		_value     = test_item_unmarshall (_rpc_value, axl_false);
		
		/* set the value */
		_result->array[iterator] = _value;

		/* update the iterator */
		iterator++;
	}
	/* deallocate memory used by the xml-rpc array */
	if (dealloc)
		vortex_xml_rpc_array_free (ref);

	return _result;
}

ItemArray * test_itemarray_new  (int count)
{
	ItemArray * array;
	/* create the reference */
	array        = axl_new (ItemArray, 1);
	array->count = count;
	array->array = axl_new (Item *, count);

	/* return the result */
	return array;
}

ItemArray * test_itemarray_copy (ItemArray * ref)
{
	ItemArray * array;
	int         iterator = 0;

	if (ref == NULL)
		return NULL;

	/* create the reference */
	array        = axl_new (ItemArray, 1);
	array->count = ref->count;
	if (array->count == 0)
		return array;

	/* allocate enough space */
	array->array = axl_new (Item *, array->count);
	while (iterator < ref->count) {

		/* copy position */
		array->array[iterator] = test_item_copy (ref->array[iterator]);

		/* update the iterator */
		iterator++;
	}

	/* return array created */
	return array;
}

void test_itemarray_free (ItemArray * ref)
{
	int iterator = 0;

	if (ref == NULL)
		return;

	while (iterator < ref->count) {
		/* release the content */
		test_item_free (ref->array[iterator]);

		/* update the iterator */
		iterator++;
	}

	/* release the array reference itself */
	axl_free (ref->array);
	axl_free (ref);

	return;
}

Item * test_itemarray_get (ItemArray * ref, int index)
{
	/* check received reference */
	v_return_val_if_fail (ref, NULL);

	/* check index access */
	v_return_val_if_fail (index >= 0 &&  index < ref->count,  NULL);

	/* return the content */
	return ref->array[index];
}

void test_itemarray_set (ItemArray * ref, int index, Item * value)
{
	v_return_if_fail (ref);
	/* check index access */
	v_return_if_fail (index >= 0 &&  index < ref->count);

	/* set the value */
	ref->array [index] = value;

	return;
}

void test_itemarray_add (ItemArray * ref, Item * value)
{
	int iterator = 0;

	/* check index access */
	v_return_if_fail (ref && value);

	/* find the next free bucket */
	while (iterator < ref->count) {

		/* check free bucket */
		if (ref->array[iterator] == NULL) {
			/* found free bucket, set the data and return */
			ref->array[iterator] = value;
			return;
		} /* end if */

		/* next position */
		iterator++;

	} /* end while */

	return;
}

int test_itemarray_count (ItemArray * ref)
{
	/* perform some checks */
	v_return_val_if_fail (ref, -1);

	/* return the count */
	return ref->count;
}

