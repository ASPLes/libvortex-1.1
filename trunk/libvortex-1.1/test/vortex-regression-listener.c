/**
 *  LibVortex:  A BEEP implementation for af-arch
 *  Copyright (C) 2006 Advanced Software Production Line, S.L.
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307 USA
 */

/* include vortex library */
#include <vortex.h>

/* include vortex tunnel support */
#include <vortex_tunnel.h>

/* include source code generated by xml-rpc-gen to test xml-rpc
 * profile */
#include <service_dispatch.h>

#ifdef AXL_OS_UNIX
#include <signal.h>
#endif

/** 
 * Profile use to identify the regression test server.
 */
#define REGRESSION_URI "http://iana.org/beep/transient/vortex-regression"

/** 
 * A profile to check default close channel action.
 */
#define REGRESSION_URI_2 "http://iana.org/beep/transient/vortex-regression/2"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_3 "http://iana.org/beep/transient/vortex-regression/3"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_4 "http://iana.org/beep/transient/vortex-regression/4"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_5 "http://iana.org/beep/transient/vortex-regression/5"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_6 "http://iana.org/beep/transient/vortex-regression/6"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_6bis "http://iana.org/beep/transient/vortex-regression/6bis"

/**
 * A profile to check close in transit support.
 */ 
#define CLOSE_IN_TRANSIT_URI "http://iana.org/beep/transient/close-in-transit"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_ZERO "http://iana.org/beep/transient/vortex-regression/zero"

/** 
 * A profile to check connection timeout against unresponsive
 * listeners.
 */
#define REGRESSION_URI_LISTENERS "http://iana.org/beep/transient/vortex-regression/fake-listener"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_ZERO "http://iana.org/beep/transient/vortex-regression/zero"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_BLOCK_TLS "http://iana.org/beep/transient/vortex-regression/block-tls"

/** 
 * A regression test profile that allows to check if the listener can
 * send data just after accepting the channel to be created.
 */
#define REGRESSION_URI_FAST_SEND "http://iana.org/beep/transient/vortex-regression/fast-send"

/** 
 * A regression test profile to check channel deny operations. This
 * profile is supported by the remote listener.
 */
#define REGRESSION_URI_DENY_SUPPORTED "http://iana.org/beep/transient/vortex-regression/deny_supported"

/** 
 * A regression test profile to check channel deny operations. This
 * profile is supported by the remote listener.
 */
#define REGRESSION_URI_CLOSE_AFTER_LARGE_REPLY "http://iana.org/beep/transient/vortex-regression/close-after-large-reply"

void frame_received_fake_listeners  (VortexChannel    * channel,
				     VortexConnection * connection,
				     VortexFrame      * frame,
				     axlPointer           user_data)
{
	VortexConnection * listener;
	VortexCtx        * ctx = CONN_CTX (connection);

	/* check commands */
	if (axl_cmp (vortex_frame_get_payload (frame), "create-listener")) {
		/* create listener command received */

		printf ("RECEIVED: create-listener request..creating at 0.0.0.0:44012\n");

		/* create the listener */
		listener = vortex_listener_new (ctx, "0.0.0.0", "44012", NULL, NULL);
		if (! vortex_connection_is_ok (listener, false)) {
			printf ("Test 12 (8): failed to start fake listener..\n");
			vortex_channel_send_err (channel, "failed to create listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to block listener created..\n");
		vortex_connection_block (listener, true);

		/* associate listener to the channel */
		vortex_channel_set_data (channel, 
					 /* key and value */
					 "listener", listener);
		
		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener created", 16, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_cmp (vortex_frame_get_payload (frame), "unlock-listener")) {
		/* unlock listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to unlock listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to unlock listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to unblock listener created..\n");
		vortex_connection_block (listener, false);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener unblocked", 18, vortex_frame_get_msgno (frame));
		return;

	} else if (axl_cmp (vortex_frame_get_payload (frame), "close-listener")) {

		/* close listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to close listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to close listener", 24, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to close listener created..\n");
		vortex_listener_shutdown (listener, true);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener closed", 15, vortex_frame_get_msgno (frame));
		return;
		
	} /* end if */

	/* default reply error */
	vortex_channel_send_err (channel,"", 0, vortex_frame_get_msgno (frame));
	return;
}

void frame_received (VortexChannel    * channel,
		     VortexConnection * connection,
		     VortexFrame      * frame,
		     axlPointer           user_data)
{
	/* check some commands */
	if (axl_cmp (vortex_frame_get_payload (frame), 
		     "GET serverName")) {
		printf ("Received request to return serverName=%s..\n", vortex_connection_get_server_name (connection));
		
		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel,
					 vortex_connection_get_server_name (connection),
					 strlen (vortex_connection_get_server_name (connection)),
					 vortex_frame_get_msgno (frame));
		return;
	} /* end if */

	/* DEFAULT REPLY, JUST ECHO */
	/* reply the peer client with the same content */
	vortex_channel_send_rpy (channel,
				 vortex_frame_get_payload (frame),
				 vortex_frame_get_payload_size (frame),
				 vortex_frame_get_msgno (frame));
	return;
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_replies (VortexChannel    * channel,
			     VortexConnection * connection,
			     VortexFrame      * frame,
			     axlPointer         user_data)
{
	
	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame));
		vortex_channel_send_msg (channel, "MSG###1###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###2###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###3###", 10, NULL);
	} /* end if */
	return;
}

/* message size: 4096 */
#define TEST_REGRESION_URI_4_MESSAGE "This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary content. This is a large file that contains arbitrary ."

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_replies (VortexChannel    * channel,
				 VortexConnection * connection,
				 VortexFrame      * frame,
				 axlPointer         user_data)
{
	int iterator;

	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
		/* reply with a file (simulating it) */ 
		iterator = 0;
		
		/* send 8192 messages of 4096 octects = 32768K = 32M */
		while (iterator < 8192) {
			/* send the reply */
			if (!vortex_channel_send_ans_rpy (channel, 
							  /* the message reply */
							  TEST_REGRESION_URI_4_MESSAGE, 4096,
							  /* the MSG num we are replying to */
							  vortex_frame_get_msgno (frame))) {

				/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable to send ans reply\n",
					REGRESSION_URI_4);
				return;
			} /* end if */
			
			/* update iterator */
			iterator++;
		} /* end while */

		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission\n",
					REGRESSION_URI_4);
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
	} /* end if */

	return;
}

int limit_transfer_frame_size (VortexChannel *channel, int next_seq_no, int message_size, int max_seq_no, axlPointer user_data) 
{
	return VORTEX_MIN (PTR_TO_INT(user_data), VORTEX_MIN (message_size, max_seq_no - next_seq_no + 1));
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_transfer_selected_file (VortexChannel    * channel,
						VortexConnection * connection,
						VortexFrame      * frame,
						axlPointer         user_data)
{
	FILE * file;
	char * buffer[4096];
	int    bytes_read;
	int    total_bytes;

	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {

		/* check "change-mss" message */
		if (axl_cmp (vortex_frame_get_payload (frame), "change-mss")) {
			/* request to change mss; configure the
			 * segmentator to limit transfer to tcp
			 * maximum segment size configured */
			vortex_connection_set_next_frame_size_handler (connection, 
								       limit_transfer_frame_size, INT_TO_PTR (vortex_connection_get_mss (connection) - 60));
			
			/* send reply */
			printf ("Request to change frame segmentator to up %d bytes (TCP MSS(%d) - BEEP HEADERS(60)\n",
				vortex_connection_get_mss (connection) - 60, vortex_connection_get_mss (connection));
			vortex_channel_send_rpy (channel, 
						 vortex_frame_get_payload (frame), 
						 vortex_frame_get_payload_size (frame), 
						 vortex_frame_get_msgno (frame));
			return;
		}
		
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_5);
		/* reply with a file (simulating it) */ 
		
		file = fopen ((char *) vortex_frame_get_payload (frame), "r");
		if (file == NULL) {
			printf ("FAILED to open file: %s..\n", (char*) vortex_frame_get_payload (frame));
			vortex_channel_send_err (channel, 
						 "Unable to open file requested",
						 29, 
						 vortex_frame_get_msgno (frame));
			return;
		} /* end if */
		printf ("Sending file: %s\n", (char*) vortex_frame_get_payload (frame));
		
		/* reply the peer client with the same content 10 times */
		total_bytes = 0;
		do {
			/* read content */
			bytes_read = fread (buffer, 1, 4096, file);
			
			/* update total count */
			total_bytes += bytes_read;
			
			/* break if eof is found */
			if (bytes_read == 0) 
				break;
			
			/* printf ("Sending the reply: bytes %d..\n", bytes_read); */
			if (! vortex_channel_send_ans_rpy (channel,
							   buffer, 
							   bytes_read, 
							   vortex_frame_get_msgno (frame))) {
				fprintf (stderr, "ERROR: There was an error while sending the reply message");
				break;
				
			} /* end if */
			
		} while (true);

		/* close file */
		fclose (file);
	
		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission for: %s\n",
					REGRESSION_URI_5, (char *) vortex_frame_get_payload (frame));
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
		
	} /* end if */

	return;
}

bool     start_channel (int                channel_num, 
			VortexConnection * connection, 
			axlPointer           user_data)
{
	/* implement profile requirement for allowing starting a new
	 * channel to return false denies channel creation to return
	 * true allows create the channel */
	return true;
}

bool     close_channel (int                channel_num, 
			VortexConnection * connection, 
			axlPointer           user_data)
{
	/* implement profile requirement for allowing to closeing a
	 * the channel to return false denies channel closing to
	 * return true allows to close the channel */
	return true;
}

bool     on_accepted (VortexConnection * connection, axlPointer data)
{
	printf ("New connection accepted from: %s:%s\n", 
		 vortex_connection_get_host (connection),
		 vortex_connection_get_port (connection));

	/* return true to accept the connection to be created */
	return true;
}

bool     sasl_anonymous_validation (VortexConnection * connection,
				    const char       * anonymous_token)
{
	if (axl_cmp ("test@aspl.es", anonymous_token)) {
		printf ("Received anonymous validation for: test@aspl.es, replying OK\n");
		return true;
	}
	return false;
}

bool     sasl_external_validation (VortexConnection * connection,
				   const char       * auth_id)
{
	if (axl_cmp ("acinom", auth_id)) {
		return true;
	}
	
	printf ("Received external validation for: %s, replying FAILED\n", auth_id);
	return false;
}

bool     sasl_external_validation_full (VortexConnection * connection,
					const char       * auth_id,
					axlPointer           user_data)
{
	
	if (axl_cmp ("external!", (char*)user_data )) {
		return sasl_external_validation (connection, auth_id);
	}

	printf ("Received external validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.",
		 auth_id);
	return false;
}



/* sasl validation handlers */
bool     sasl_plain_validation  (VortexConnection * connection,
				 const char       * auth_id,
				 const char       * auth_proxy_id,
				 const char       * password)
{
	/* perform validation */
	if (axl_cmp (auth_id, "bob") && 
	    axl_cmp (password, "secret")) {
		return true;
	}
	/* deny SASL request to authenticate remote peer */
	return false;
}

bool     sasl_plain_validation_full  (VortexConnection * connection,
				 const char       * auth_id,
				 const char       * auth_proxy_id,
				 const char       * password,
				 axlPointer user_data)
{
	if (axl_cmp ("plain!", (char*)user_data )) {
		return sasl_plain_validation (connection, auth_id, auth_proxy_id, password);
	}
	printf ("Received PLAIN validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return false;
}

char  * sasl_cram_md5_validation (VortexConnection * connection,
				  const char  * auth_id)
{
	if (axl_cmp (auth_id, "bob"))
		return axl_strdup ("secret");
	return NULL;
}

char  * sasl_cram_md5_validation_full (VortexConnection * connection,
				  const char  * auth_id,
				  axlPointer user_data)
{
	if (axl_cmp ("cram md5!", (char*)user_data )) {
		return sasl_cram_md5_validation (connection, auth_id);
	}
	printf ("Received cram md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return false;
}

char  * sasl_digest_md5_validation (VortexConnection * connection,
				    const char  * auth_id,
				    const char  * authorization_id,
				    const char  * realm)
{
	/* use the same code for the cram md5 validation */
	return sasl_cram_md5_validation (connection, auth_id);
}

char  * sasl_digest_md5_validation_full (VortexConnection * connection,
					 const char  * auth_id,
					 const char  * authorization_id,
					 const char  * realm,
					 axlPointer user_data)
{
	if (axl_cmp ("digest md5!", (char*)user_data )) {
		return sasl_digest_md5_validation (connection, auth_id, authorization_id, realm);
	}

	printf ("Received digest md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return false;
}


#ifdef AXL_OS_UNIX
void __block_test (int value) 
{
	VortexAsyncQueue * queue;

	printf ("******\n");
	printf ("****** Received a signal (the regression test is failing): pid %d..locking..!!!\n", vortex_getpid ());
	printf ("******\n");

	/* block the caller */
	queue = vortex_async_queue_new ();
	vortex_async_queue_pop (queue);

	return;
}
#endif

VortexMutex doing_exit_mutex;
bool        __doing_exit = false;

/* listener context */
VortexCtx * ctx = NULL;

void __terminate_vortex_listener (int value)
{
	
	vortex_mutex_lock (&doing_exit_mutex);
	if (__doing_exit) {
		vortex_mutex_unlock (&doing_exit_mutex);

		return;
	}
	printf ("Terminating vortex regression listener..\n");
	__doing_exit = true;
	vortex_mutex_unlock (&doing_exit_mutex);

	/* unlocking listener */
	vortex_listener_unlock (ctx);

	return;
}

/** 
 * @brief Close in transit frame received handler. 
 */
void close_in_transit_received (VortexChannel    * channel,
				VortexConnection * conn,
				VortexFrame      * frame,
				axlPointer         user_data)
{
	/* reply to the frame received and close the channel */
	vortex_channel_send_rpy (channel,
				 "", 0, vortex_frame_get_msgno (frame));
	
	/* now close the channel */
	if (! vortex_channel_close (channel, NULL)) {
		fprintf (stderr, "FAILED TO CLOSE CHANNEL (close in transit profile)");
		return;
	}
	return;
}

bool check_profiles_adviced (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	axlList    * profiles = vortex_connection_get_remote_profiles (connection);
	int          iterator;
	const char * uri;

	
	printf ("Check profiles announced: %d\n", axl_list_length (profiles));
	iterator = 0;
	while (iterator < axl_list_length (profiles)) {
		/* get uri */
		uri = (const char *) axl_list_get_nth (profiles, iterator);
		printf ("  uri found: %s\n", uri);

		/* next position */
		iterator++;
	}  /* end while */

	if (axl_list_length (profiles) < 3) {
		printf ("ERROR: Expected to find 3 profiles registered, but found: %d..\n",
			axl_list_length (profiles));
		axl_list_free (profiles);
		return false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		axl_list_free (profiles);
		return false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		axl_list_free (profiles);
		return false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		axl_list_free (profiles);
		return false;
	}
	
	/* ok */
	axl_list_free (profiles);
	return true;

}

bool check_profiles_adviced_bis (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		return false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		return false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		return false;
	}
	
	/* return true if the profile list is 0 */
	return true;

}

/* a flag that allows to configure if the TLS request is accepted */
bool enable_block_tls_queries = false;

bool start_channel_block_tls (int channel_num, VortexConnection * connection, axlPointer user_data)
{
	printf ("Received request to block TLS query..\n");

	/* block next tls query */
	enable_block_tls_queries = true;
	return true;
}

axlPointer block_ctx_creation (VortexConnection * connection, axlPointer user_data)
{
	/* simulate a failure creating the SSL context.. */
	printf ("Simulate a SSL context creation failure..\n");
	return NULL;
}

bool regression_tls_handle_query (VortexConnection * connection, char * serverName)
{

	printf ("Receiving request to start tls auth, with status=%d..\n", enable_block_tls_queries);
	if (enable_block_tls_queries) {
		/* return to not accept TLS query but revert state for
		 * the next query */
		enable_block_tls_queries = false;

		/* but also configure next blocking function (to
		 * simulate a failure at the TLS protocol) */
		vortex_tls_set_ctx_creation (connection, block_ctx_creation, NULL);

		return false;
	} /* end if */

	return true;
}

void added_channel_fast_send (VortexChannel * channel, axlPointer user_data)
{
	/* check if the channel is running the fast send profile */
	if (vortex_channel_is_running_profile (channel, REGRESSION_URI_FAST_SEND)) {
		printf ("Found channel running %s..sending two messages\n", REGRESSION_URI_FAST_SEND);
		if (! vortex_channel_send_msg (channel, "message 1", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 1 at fast send..\n");
		}

		if (! vortex_channel_send_msg (channel, "message 2", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 2 at fast send..\n");
		}
		printf ("Messages sent..ok\n");
	}
}

bool on_accepted_fast_send (VortexConnection * connection, axlPointer data)
{
	/* configure the added channel handler */
	vortex_connection_set_channel_added_handler (connection, added_channel_fast_send, NULL);

	return true;
}


bool deny_supported (int channel_num, VortexConnection *connection, axlPointer user_data) 
{
	/* do not accept channel; never */
	return false;
}

/** 
 * @internal Handler that replies to a message received with huge
 * content and then closes.
 * 
 */
void frame_received_close_after_large_reply (VortexChannel    * channel,
					     VortexConnection * connection,
					     VortexFrame      * frame,
					     axlPointer         user_data)
{
	char             * message;

	/* check message that only requires a reply followed by a message */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG &&
	    axl_cmp (vortex_frame_get_payload (frame), "send-message")) {
		printf ("Test-02d: received request to reply and send a new message..\n");
		if (! vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		if (! vortex_channel_send_msg (channel, "", 0, NULL)) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		printf ("Test-02d: received a request to reply and send a new message..ok\n");
		return;
	} /* end if */

	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Test-02d: received request, sending reply: '%s...\n", (char*) vortex_frame_get_payload (frame));
		/* send big reply */
		message = axl_new (char, 32767);
		if (! vortex_channel_send_rpy (channel, message, 32767, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		axl_free (message);

		/* wait a bit to allow sending all pending content */
		printf ("Test-02d: waiting to flush all content..\n");
		if (! vortex_channel_block_until_replies_are_sent (channel, -1)) {
			printf ("!!!!! ERROR: found error while checking if all replies were sent..\n");
			return;
		}

		/* now close the connection */
		printf ("Test-02d: sent!..now close the connection...\n");
		if (! vortex_connection_close (connection)) {
			printf ("!!!!! ERROR: failed to close connection, unable to complete test-02d..\n");
			return;
		}

		printf ("Test-02d: managed to send reply and close the connection..\n");
		return;
	} /* end if */

	printf ("Test-02d: received unhandled frame type..\n");

	return;
}


int  main (int  argc, char ** argv) 
{

	/* install default handling to get notification about
	 * segmentation faults */
#ifdef AXL_OS_UNIX
	signal (SIGSEGV, __block_test);
	signal (SIGABRT, __block_test);
	signal (SIGTERM,  __terminate_vortex_listener);
#endif

	vortex_mutex_create (&doing_exit_mutex);

	/* create the context */
	ctx = vortex_ctx_new ();

	/* init vortex library */
	if (! vortex_init_ctx (ctx)) {
		/* unable to init context */
		vortex_ctx_free (ctx);
		return -1;
	} /* end if */

	if (argc > 1 && 0 == strcmp (argv[1], "-v")) {
		vortex_log_enable (ctx, true);
		vortex_log2_enable (ctx, true);
	}

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a extended start */
	vortex_profiles_register_extended_start (ctx, REGRESSION_URI_2,
						 NULL, NULL);

	/* register more profiles */
	vortex_profiles_register (ctx, REGRESSION_URI_3,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_replies, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_4,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_replies, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_5,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_transfer_selected_file, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6,
				  /* start message */
				  check_profiles_adviced, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6bis,
				  /* start message */
				  check_profiles_adviced_bis, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ZERO,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_LISTENERS,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_BLOCK_TLS,
				  start_channel_block_tls, NULL,
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);


	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_FAST_SEND,
				  NULL, NULL,
				  NULL, NULL,
				  NULL, NULL);
	vortex_listener_set_on_connection_accepted (ctx, on_accepted_fast_send, NULL);

	vortex_profiles_register (ctx, REGRESSION_URI_DENY_SUPPORTED,
				  /* handler that always denies */
				  deny_supported, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* registre a profile to send a rpy huge and then close a channel */
	vortex_profiles_register (ctx, REGRESSION_URI_CLOSE_AFTER_LARGE_REPLY,
				  /* start channel handler */
				  NULL, NULL,
				  /* close channel handler */
				  NULL, NULL,
				  /* frame received handler */
				  frame_received_close_after_large_reply, NULL);
				  

	/* enable accepting incoming tls connections, this step could
	 * also be read as register the TLS profile */
	if (! vortex_tls_accept_negotiation (ctx, regression_tls_handle_query, NULL, NULL)) {
		printf ("Unable to start accepting TLS profile requests");
		return -1;
	}

	if (vortex_sasl_is_enabled () ) {
		/* set default ANONYMOUS validation handler */
		vortex_sasl_set_anonymous_validation (ctx, sasl_anonymous_validation);

		/* accept SASL ANONYMOUS incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_ANONYMOUS)) {
			printf ("Unable to make Vortex Libray to accept SASL ANONYMOUS profile");
			return -1;
		}

		/* set default EXTERNAL validation handler */
		vortex_sasl_set_external_validation (ctx, sasl_external_validation);
		
		/* accept SASL EXTERNAL incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_EXTERNAL)) {
			printf ("Unable to make Vortex Libray to accept SASL EXTERNAL profile");
			return -1;
		}
		
		/* set default PLAIN validation handler */
		vortex_sasl_set_plain_validation (ctx, sasl_plain_validation);
		
		/* accept SASL PLAIN incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_PLAIN)) {
			printf ("Unable to make Vortex Libray to accept SASL PLAIN profile");
			return -1;
		}
		
		/* set default CRAM-MD5 validation handler */
		vortex_sasl_set_cram_md5_validation (ctx, sasl_cram_md5_validation);
		
		/* accept SASL CRAM-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_CRAM_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL CRAM-MD5 profile");
			return -1;
		}
		
		/* set default DIGEST-MD5 validation handler */
		vortex_sasl_set_digest_md5_validation (ctx, sasl_digest_md5_validation);
		
		/* accept SASL DIGEST-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_DIGEST_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL DIGEST-MD5 profile");
			return -1;
		} /* end if */

		/* configure default realm for all connections for the DIGEST-MD5 */
		vortex_listener_set_default_realm (ctx, "aspl.es");  

	} else {
		printf("Skipping SASL setup, since Vortex is not configured with SASL support\n");
	}
	
	/* configure support for TUNNEL profile support */
	vortex_tunnel_accept_negotiation (ctx, NULL, NULL);
	
	/* enable XML-RPC profile */
        vortex_xml_rpc_accept_negotiation (
		/* context */
		ctx, 
                /* no resource validation function */
                NULL,
                /* no user space data for the validation resource
		 * function. */
                NULL,
                service_dispatch,
                /* no user space data for the dispatch function. */
                NULL);

	/* configure close in transit profile */
	vortex_profiles_register (ctx, CLOSE_IN_TRANSIT_URI,
				  /* just accept all channels to be created */
				  NULL, NULL,
				  /* just accept all channels to be closed */
				  NULL, NULL,
				  close_in_transit_received, NULL);
	
	/* create a vortex server */
	vortex_listener_new (ctx, "0.0.0.0", "44010", NULL, NULL);

	/* create a vortex server to check the tunnel profile
	 * support */
	vortex_listener_new (ctx, "0.0.0.0", "44110", NULL, NULL);

	/* configure connection notification  */
	vortex_listener_set_on_connection_accepted (ctx, on_accepted, NULL);

	/* wait for listeners (until vortex_exit is called) */
	printf ("ready and waiting..\n");

	vortex_listener_wait (ctx);

	printf ("terminating the listener ..\n");

	/* terminate process */
	vortex_exit_ctx (ctx, true);

	return 0;
}

