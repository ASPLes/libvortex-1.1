/**
 * C client stub to invoke services exported by the XML-RPC component: test.
 *
 * This file was generated by xml-rpc-gen tool, from Vortex Library
 * project.
 *
 * Vortex Library homepage: http://vortex.aspl.es
 * Axl Library homepage: http://xml.aspl.es
 * Advanced Software Production Line: http://www.aspl.es
 */
#include <test_types.h>

/* (un)marshaller support functions  */
XmlRpcStruct * test_item_marshall (VortexCtx * _ctx_, Item * ref, axl_bool  dealloc)
{
	XmlRpcStruct       * _result;
	XmlRpcStructMember * _member;

	/* check received reference */
	if (ref == NULL)
		return NULL;
	/* create the struct */
	_result = vortex_xml_rpc_struct_new (2);

	/* position member */
	_member = vortex_xml_rpc_struct_member_new ("position", method_value_new (_ctx_, XML_RPC_INT_VALUE, INT_TO_PTR (ref->position)));
	vortex_xml_rpc_struct_add_member (_result, _member);

	/* string_position member */
	_member = vortex_xml_rpc_struct_member_new ("string_position", method_value_new (_ctx_, XML_RPC_STRING_VALUE, ref->string_position ? ref->string_position : ""));
	vortex_xml_rpc_struct_add_member (_result, _member);

	/* dealloc data source */
	if (dealloc)
		test_item_free (ref);

	/* return result created */
	return _result;
}

Item * test_item_unmarshall (XmlRpcStruct * ref, axl_bool  dealloc)
{
	Item * _result;

	/* check received reference */
	if (ref == NULL)
		return NULL;

	/* check the number of items the provided struct */
	v_return_val_if_fail (vortex_xml_rpc_struct_get_member_count (ref) == 2, NULL);
	/* check member names */
	v_return_val_if_fail (vortex_xml_rpc_struct_check_member_names (ref, 2, "position", "string_position"), NULL);
	/* check member types */
	v_return_val_if_fail (vortex_xml_rpc_struct_check_member_types (ref, 2, "int", "string"), NULL);

	_result = test_item_new (
		vortex_xml_rpc_struct_get_member_value_as_int (ref, "position"),
		vortex_xml_rpc_struct_get_member_value_as_string (ref, "string_position"));

	/* dealloc data source */
	if (dealloc)
		vortex_xml_rpc_struct_free (ref);

	return _result;
}

/* memory (de)allocation functions */
Item * test_item_new (int position, const char * string_position)
{
	Item * _result = axl_new (Item, 1);

	_result->position = position;
	_result->string_position = axl_strdup (string_position);
	
	return _result;
}

Item * test_item_copy (Item * ref)
{
	Item * _result = NULL;

	if (ref == NULL)
		return NULL;

	_result = axl_new (Item, 1);
	_result->position = ref->position;
	_result->string_position = axl_strdup (ref->string_position);
	
	return _result;
}

void test_item_free (Item * ref)
{
	if (ref == NULL)
		return;
	if (ref->string_position)
		axl_free (ref->string_position);
	if (ref != NULL)
		axl_free (ref);
	return;
}

