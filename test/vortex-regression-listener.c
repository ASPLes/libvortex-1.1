/*
 *  LibVortex:  A BEEP (RFC3080/RFC3081) implementation.
 *  Copyright (C) 2008 Advanced Software Production Line, S.L.
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public License
 *  as published by the Free Software Foundation; either version 2.1 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this program; if not, write to the Free
 *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307 USA
 *  
 *  You may find a copy of the license under this software is released
 *  at COPYING file. This is LGPL software: you are welcome to
 *  develop proprietary applications using this library without any
 *  royalty or fee but returning back any change, improvement or
 *  addition in the form of source code, project image, documentation
 *  patches, etc. 
 *
 *  For commercial support on build BEEP enabled solutions contact us:
 *          
 *      Postal address:
 *         Advanced Software Production Line, S.L.
 *         C/ Antonio Suarez Nº 10, 
 *         Edificio Alius A, Despacho 102
 *         Alcalá de Henares 28802 (Madrid)
 *         Spain
 *
 *      Email address:
 *         info@aspl.es - http://www.aspl.es/vortex
 */
/* include vortex library */
#include <vortex.h>

/* include vortex tunnel support */
#include <vortex_tunnel.h>

/* include sasl support */
#include <vortex_sasl.h>

/* include tls support */
#include <vortex_tls.h>

/* include source code generated by xml-rpc-gen to test xml-rpc
 * profile */
#include <service_dispatch.h>

/* include local support */
#include <vortex-regression-common.h>

#ifdef AXL_OS_UNIX
#include <signal.h>
#endif

/** 
 * Profile use to identify the regression test server.
 */
#define REGRESSION_URI "http://iana.org/beep/transient/vortex-regression"

/** 
 * A profile to check default close channel action.
 */
#define REGRESSION_URI_2 "http://iana.org/beep/transient/vortex-regression/2"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_3 "http://iana.org/beep/transient/vortex-regression/3"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_4 "http://iana.org/beep/transient/vortex-regression/4"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_5 "http://iana.org/beep/transient/vortex-regression/5"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_6 "http://iana.org/beep/transient/vortex-regression/6"

/** 
 * A profile to check wrong order reply.
 */
#define REGRESSION_URI_6bis "http://iana.org/beep/transient/vortex-regression/6bis"

/**
 * A profile to check close in transit support.
 */ 
#define CLOSE_IN_TRANSIT_URI "http://iana.org/beep/transient/close-in-transit"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_ZERO "http://iana.org/beep/transient/vortex-regression/zero"

/** 
 * A profile to check connection timeout against unresponsive
 * listeners.
 */
#define REGRESSION_URI_LISTENERS "http://iana.org/beep/transient/vortex-regression/fake-listener"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_ZERO "http://iana.org/beep/transient/vortex-regression/zero"

/** 
 * A profile to check sending zeroed binary frames.
 */
#define REGRESSION_URI_BLOCK_TLS "http://iana.org/beep/transient/vortex-regression/block-tls"

/** 
 * A regression test profile that allows to check if the listener can
 * send data just after accepting the channel to be created.
 */
#define REGRESSION_URI_FAST_SEND "http://iana.org/beep/transient/vortex-regression/fast-send"

/** 
 * A regression test profile to check channel deny operations. This
 * profile is supported by the remote listener.
 */
#define REGRESSION_URI_DENY_SUPPORTED "http://iana.org/beep/transient/vortex-regression/deny_supported"

/** 
 * A regression test profile to check channel deny operations. This
 * profile is supported by the remote listener.
 */
#define REGRESSION_URI_CLOSE_AFTER_LARGE_REPLY "http://iana.org/beep/transient/vortex-regression/close-after-large-reply"

/** 
 * Profile use to identify the regression test client and server mime
 * support.
 */
#define REGRESSION_URI_MIME "http://iana.org/beep/transient/vortex-regression/mime"

/** 
 * Profile use to identify the regression test client and server mime
 * support.
 */
#define REGRESSION_URI_ORDERED_DELIVERY "http://iana.org/beep/transient/vortex-regression/ordered-delivery"

/** 
 * Profile use to identify the regression test client and server mime
 * support.
 */
#define REGRESSION_URI_SUDDENTLY_CLOSE "http://iana.org/beep/transient/vortex-regression/suddently-close"

/**
 * Profile use to identify the regression test to check replies mixed
 * (ANS..NUL with RPY).
 */
#define REGRESSION_URI_MIXING_REPLIES "http://iana.org/beep/transient/vortex-regression/mixing-replies"

/**
 * Profile used to identify the regression test to check connection
 * close after ans/nul reply.
 */
#define REGRESSION_URI_ANS_NUL_REPLY_CLOSE "http://iana.org/beep/transient/vortex-regression/ans-nul-reply-close"

/**
 * Profile used to identify the regression test to check connection
 * close after ans/nul reply.
 */
#define REGRESSION_URI_CLOSE_AFTER_ANS_NUL_REPLIES "http://iana.org/beep/transient/vortex-regression/close-after-ans-nul-replies"

/**
 * Profile that does nothing.
 */
#define REGRESSION_URI_NOTHING "http://iana.org/beep/transient/vortex-regression/nothing"

/**
 * Profile that allows to check seqno limits.
 */
#define REGRESSION_URI_SEQNO_EXCEEDED "http://iana.org/beep/transient/vortex-regression/seqno-exceeded"

void frame_received_fake_listeners  (VortexChannel    * channel,
				     VortexConnection * connection,
				     VortexFrame      * frame,
				     axlPointer           user_data)
{
	VortexConnection * listener;
	VortexCtx        * ctx = CONN_CTX (connection);

	/* check commands */
	if (axl_cmp (vortex_frame_get_payload (frame), "create-listener")) {
		/* create listener command received */

		printf ("RECEIVED: create-listener request..creating at 0.0.0.0:44012\n");

		/* create the listener */
		listener = vortex_listener_new (ctx, "0.0.0.0", "44012", NULL, NULL);
		if (! vortex_connection_is_ok (listener, axl_false)) {
			printf ("Test 12 (8): failed to start fake listener..\n");
			vortex_channel_send_err (channel, "failed to create listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to block listener created..\n");
		vortex_connection_block (listener, axl_true);

		/* associate listener to the channel */
		vortex_channel_set_data (channel, 
					 /* key and value */
					 "listener", listener);
		
		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener created", 16, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_cmp (vortex_frame_get_payload (frame), "unlock-listener")) {
		/* unlock listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to unlock listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to unlock listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to unblock listener created..\n");
		vortex_connection_block (listener, axl_false);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener unblocked", 18, vortex_frame_get_msgno (frame));
		return;

	} else if (axl_cmp (vortex_frame_get_payload (frame), "close-listener")) {

		/* close listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to close listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to close listener", 24, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to close listener created..\n");
		vortex_listener_shutdown (listener, axl_true);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener closed", 15, vortex_frame_get_msgno (frame));
		return;
		
	} /* end if */

	/* default reply error */
	vortex_channel_send_err (channel,"", 0, vortex_frame_get_msgno (frame));
	return;
}

void frame_received (VortexChannel    * channel,
		     VortexConnection * connection,
		     VortexFrame      * frame,
		     axlPointer           user_data)
{
	int window_size;

	/* check some commands */
	if (axl_cmp (vortex_frame_get_payload (frame), "GET serverName")) {
		printf ("Received request to return serverName=%s..\n", vortex_connection_get_server_name (connection));
		
		/* reply the peer client with server name */
		vortex_channel_send_rpy (channel,
					 vortex_connection_get_server_name (connection),
					 strlen (vortex_connection_get_server_name (connection)),
					 vortex_frame_get_msgno (frame));
		return;
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "window_size=", 12)) {
		printf ("Received request to change window size to: %s..\n", 
			(char *) vortex_frame_get_payload (frame) + 12);
		window_size = atoi ((char *) vortex_frame_get_payload (frame) + 12);
		/* changing window size */
		vortex_channel_set_window_size (channel, window_size);

		/* ok reply to the peer client   */
		vortex_channel_send_rpy (channel, "ok", 2, vortex_frame_get_msgno (frame));
		return;
		
	} /* end if */

	/* DEFAULT REPLY, JUST ECHO */
	/* reply the peer client with the same content */
	vortex_channel_send_rpy (channel,
				 vortex_frame_get_payload (frame),
				 vortex_frame_get_payload_size (frame),
				 vortex_frame_get_msgno (frame));
	return;
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_replies (VortexChannel    * channel,
			     VortexConnection * connection,
			     VortexFrame      * frame,
			     axlPointer         user_data)
{
	VortexAsyncQueue * queue;
	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {

		vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame));
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 10000);
		vortex_async_queue_unref (queue);
		vortex_channel_send_msg (channel, "MSG###1###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###2###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###3###", 10, NULL);

	} /* end if */
	return;
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_replies (VortexChannel    * channel,
				 VortexConnection * connection,
				 VortexFrame      * frame,
				 axlPointer         user_data)
{
	int     iterator;
	int     block_size;
	int     block_num;
	char ** values;


	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);

		/* parse message received */
		values     = axl_split (vortex_frame_get_payload (frame), 1, ",");
		block_size = atoi (values[1]);
		block_num  = atoi (values[2]);
		axl_freev (values);
		printf ("Sending content (ANS/NUL test: %s, block size: %d, block num: %d)\n", 
			REGRESSION_URI_4, block_size, block_num);

		/* reply with a file (simulating it) */ 
		iterator = 0;
		
		/* send block_num messages of block_size octects  */
		while (iterator < block_num) {
			/* send the reply */
			if (!vortex_channel_send_ans_rpy (channel, 
							  /* the message reply */
							  TEST_REGRESION_URI_4_MESSAGE, block_size,
							  /* the MSG num we are replying to */
							  vortex_frame_get_msgno (frame))) {

				/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable to send ans reply\n",
					REGRESSION_URI_4);
				return;
			} /* end if */
			
			/* update iterator */
			iterator++;
		} /* end while */

		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission\n",
					REGRESSION_URI_4);
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
	} /* end if */

	return;
}

int limit_transfer_frame_size (VortexChannel *channel, int next_seq_no, int message_size, int max_seq_no, axlPointer user_data) 
{
	return VORTEX_MIN (PTR_TO_INT(user_data), VORTEX_MIN (message_size, max_seq_no - next_seq_no + 1));
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_transfer_selected_file (VortexChannel    * channel,
						VortexConnection * connection,
						VortexFrame      * frame,
						axlPointer         user_data)
{
	FILE * file;
	char * buffer[4096];
	int    bytes_read;
	int    total_bytes;

	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {

		/* check "change-mss" message */
		if (axl_cmp (vortex_frame_get_payload (frame), "change-mss")) {
			/* request to change mss; configure the
			 * segmentator to limit transfer to tcp
			 * maximum segment size configured */
			vortex_connection_set_next_frame_size_handler (connection, 
								       limit_transfer_frame_size, INT_TO_PTR (vortex_connection_get_mss (connection) - 60));
			
			/* send reply */
			printf ("Request to change frame segmentator to up %d bytes (TCP MSS(%d) - BEEP HEADERS(60)\n",
				vortex_connection_get_mss (connection) - 60, vortex_connection_get_mss (connection));
			vortex_channel_send_rpy (channel, 
						 vortex_frame_get_payload (frame), 
						 vortex_frame_get_payload_size (frame), 
						 vortex_frame_get_msgno (frame));
			return;
		}
		
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_5);
		/* reply with a file (simulating it) */ 
		
		file = fopen ((char *) vortex_frame_get_payload (frame), "r");
		if (file == NULL) {
			printf ("FAILED to open file: %s..\n", (char*) vortex_frame_get_payload (frame));
			vortex_channel_send_err (channel, 
						 "Unable to open file requested",
						 29, 
						 vortex_frame_get_msgno (frame));
			return;
		} /* end if */
		printf ("Sending file: %s\n", (char*) vortex_frame_get_payload (frame));
		
		/* reply the peer client with the same content 10 times */
		total_bytes = 0;
		do {
			/* read content */
			bytes_read = fread (buffer, 1, 4096, file);
			
			/* update total count */
			total_bytes += bytes_read;
			
			/* break if eof is found */
			if (bytes_read == 0) 
				break;
			
			/* printf ("Sending the reply: bytes %d..\n", bytes_read); */
			if (! vortex_channel_send_ans_rpy (channel,
							   buffer, 
							   bytes_read, 
							   vortex_frame_get_msgno (frame))) {
				fprintf (stderr, "ERROR: There was an error while sending the reply message");
				break;
				
			} /* end if */
			
		} while (axl_true);

		/* close file */
		fclose (file);
	
		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission for: %s\n",
					REGRESSION_URI_5, (char *) vortex_frame_get_payload (frame));
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
		
	} /* end if */

	return;
}

axl_bool      start_channel (int                channel_num, 
			     VortexConnection * connection, 
			     axlPointer           user_data)
{
	/* implement profile requirement for allowing starting a new
	 * channel to return axl_false denies channel creation to return
	 * axl_true allows create the channel */
	return axl_true;
}

axl_bool      close_channel (int                channel_num, 
			     VortexConnection * connection, 
			     axlPointer           user_data)
{
	/* implement profile requirement for allowing to closeing a
	 * the channel to return axl_false denies channel closing to
	 * return axl_true allows to close the channel */
	return axl_true;
}

axl_bool      on_accepted (VortexConnection * connection, axlPointer data)
{
	printf ("New connection accepted from: %s:%s\n", 
		vortex_connection_get_host (connection),
		vortex_connection_get_port (connection));

	/* return axl_true to accept the connection to be created */
	return axl_true;
}

axl_bool      sasl_anonymous_validation (VortexConnection * connection,
					 const char       * anonymous_token)
{
	if (axl_cmp ("test@aspl.es", anonymous_token)) {
		printf ("Received anonymous validation for: test@aspl.es, replying OK\n");
		return axl_true;
	}
	return axl_false;
}

axl_bool      sasl_external_validation (VortexConnection * connection,
					const char       * auth_id)
{
	if (axl_cmp ("acinom", auth_id)) {
		return axl_true;
	}
	
	printf ("Received external validation for: %s, replying FAILED\n", auth_id);
	return axl_false;
}

axl_bool      sasl_external_validation_full (VortexConnection * connection,
					     const char       * auth_id,
					     axlPointer         user_data)
{
	
	if (axl_cmp ("external!", (char*)user_data )) {
		return sasl_external_validation (connection, auth_id);
	}

	printf ("Received external validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.",
		 auth_id);
	return axl_false;
}



/* sasl validation handlers */
axl_bool      sasl_plain_validation  (VortexConnection * connection,
				      const char       * auth_id,
				      const char       * auth_proxy_id,
				      const char       * password)
{
	/* perform validation */
	if (axl_cmp (auth_id, "bob") && 
	    axl_cmp (password, "secret")) {
		return axl_true;
	}
	/* deny SASL request to authenticate remote peer */
	return axl_false;
}

axl_bool      sasl_plain_validation_full  (VortexConnection * connection,
					   const char       * auth_id,
					   const char       * auth_proxy_id,
					   const char       * password,
					   axlPointer user_data)
{
	if (axl_cmp ("plain!", (char*)user_data )) {
		return sasl_plain_validation (connection, auth_id, auth_proxy_id, password);
	}
	printf ("Received PLAIN validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}

char  * sasl_cram_md5_validation (VortexConnection * connection,
				  const char  * auth_id)
{
	if (axl_cmp (auth_id, "bob"))
		return axl_strdup ("secret");
	return NULL;
}

char  * sasl_cram_md5_validation_full (VortexConnection * connection,
				  const char  * auth_id,
				  axlPointer user_data)
{
	if (axl_cmp ("cram md5!", (char*)user_data )) {
		return sasl_cram_md5_validation (connection, auth_id);
	}
	printf ("Received cram md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}

char  * sasl_digest_md5_validation (VortexConnection * connection,
				    const char  * auth_id,
				    const char  * authorization_id,
				    const char  * realm)
{
	/* use the same code for the cram md5 validation */
	return sasl_cram_md5_validation (connection, auth_id);
}

char  * sasl_digest_md5_validation_full (VortexConnection * connection,
					 const char  * auth_id,
					 const char  * authorization_id,
					 const char  * realm,
					 axlPointer user_data)
{
	if (axl_cmp ("digest md5!", (char*)user_data )) {
		return sasl_digest_md5_validation (connection, auth_id, authorization_id, realm);
	}

	printf ("Received digest md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}


#ifdef AXL_OS_UNIX
void __block_test (int value) 
{
	VortexAsyncQueue * queue;

	printf ("******\n");
	printf ("****** Received a signal (the regression test is failing): pid %d..locking..!!!\n", vortex_getpid ());
	printf ("******\n");

	/* block the caller */
	queue = vortex_async_queue_new ();
	vortex_async_queue_pop (queue);

	return;
}
#endif

VortexMutex doing_exit_mutex;
axl_bool    __doing_exit = axl_false;

/* listener context */
VortexCtx * ctx = NULL;

void __terminate_vortex_listener (int value)
{
	
	vortex_mutex_lock (&doing_exit_mutex);
	if (__doing_exit) {
		vortex_mutex_unlock (&doing_exit_mutex);

		return;
	}
	printf ("Terminating vortex regression listener..\n");
	__doing_exit = axl_true;
	vortex_mutex_unlock (&doing_exit_mutex);

	/* unlocking listener */
	vortex_listener_unlock (ctx);

	return;
}

/** 
 * @brief Close in transit frame received handler. 
 */
void close_in_transit_received (VortexChannel    * channel,
				VortexConnection * conn,
				VortexFrame      * frame,
				axlPointer         user_data)
{
	/* reply to the frame received and close the channel */
	vortex_channel_send_rpy (channel,
				 "", 0, vortex_frame_get_msgno (frame));
	
	/* now close the channel */
	if (! vortex_channel_close (channel, NULL)) {
		fprintf (stderr, "FAILED TO CLOSE CHANNEL (close in transit profile)");
		return;
	}
	return;
}

axl_bool  check_profiles_adviced (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	axlList    * profiles = vortex_connection_get_remote_profiles (connection);
	int          iterator;
	const char * uri;

	
	printf ("Check profiles announced: %d\n", axl_list_length (profiles));
	iterator = 0;
	while (iterator < axl_list_length (profiles)) {
		/* get uri */
		uri = (const char *) axl_list_get_nth (profiles, iterator);
		printf ("  uri found: %s\n", uri);

		/* next position */
		iterator++;
	}  /* end while */

	if (axl_list_length (profiles) < 3) {
		printf ("ERROR: Expected to find 3 profiles registered, but found: %d..\n",
			axl_list_length (profiles));
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		axl_list_free (profiles);
		return axl_false;
	}
	
	/* ok */
	axl_list_free (profiles);
	return axl_true;

}

axl_bool  check_profiles_adviced_bis (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		return axl_false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		return axl_false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		return axl_false;
	}
	
	/* return axl_true if the profile list is 0 */
	return axl_true;

}

/* a flag that allows to configure if the TLS request is accepted */
axl_bool  enable_block_tls_queries = axl_false;

axl_bool  start_channel_block_tls (int channel_num, VortexConnection * connection, axlPointer user_data)
{
	printf ("Received request to block TLS query..\n");

	/* block next tls query */
	enable_block_tls_queries = axl_true;
	return axl_true;
}

axlPointer block_ctx_creation (VortexConnection * connection, axlPointer user_data)
{
	/* simulate a failure creating the SSL context.. */
	printf ("Simulate a SSL context creation failure..\n");
	return NULL;
}

axl_bool  regression_tls_handle_query (VortexConnection * connection, char * serverName)
{

	printf ("Receiving request to start tls auth, with status=%d..\n", enable_block_tls_queries);
	if (enable_block_tls_queries) {
		/* return to not accept TLS query but revert state for
		 * the next query */
		enable_block_tls_queries = axl_false;

		/* but also configure next blocking function (to
		 * simulate a failure at the TLS protocol) */
		vortex_tls_set_ctx_creation (connection, block_ctx_creation, NULL);

		return axl_false;
	} /* end if */

	return axl_true;
}

void added_channel_fast_send (VortexChannel * channel, axlPointer user_data)
{
	/* check if the channel is running the fast send profile */
	if (vortex_channel_is_running_profile (channel, REGRESSION_URI_FAST_SEND)) {
		printf ("Found channel running %s..sending two messages\n", REGRESSION_URI_FAST_SEND);
		if (! vortex_channel_send_msg (channel, "message 1", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 1 at fast send..\n");
		}

		if (! vortex_channel_send_msg (channel, "message 2", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 2 at fast send..\n");
		}
		printf ("Messages sent..ok\n");
	}
}

axl_bool  on_accepted_fast_send (VortexConnection * connection, axlPointer data)
{
	/* configure the added channel handler */
	vortex_connection_set_channel_added_handler (connection, added_channel_fast_send, NULL);

	return axl_true;
}

void added_channel_ans_nul_reply_close (VortexChannel * channel, axlPointer user_data)
{
	/* check if the channel is running the fast send profile */
	if (vortex_channel_is_running_profile (channel, REGRESSION_URI_ANS_NUL_REPLY_CLOSE)) {
		printf ("Found channel running %s..sending message\n", REGRESSION_URI_ANS_NUL_REPLY_CLOSE);

		/* send message */
		if (! vortex_channel_send_msg (channel, "message 1", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 1 at fast send..\n");
		}		

		/* report */
		printf ("Reply sent for uri %s, 2 ANS followed by 1 NUL..\n",
			REGRESSION_URI_ANS_NUL_REPLY_CLOSE);
	} /* end if */
}


axl_bool  on_accepted_ans_nul_reply_close (VortexConnection * connection, axlPointer data)
{
	/* configure the added channel handler */
	vortex_connection_set_channel_added_handler (connection, added_channel_ans_nul_reply_close, NULL);

	return axl_true;
}


axl_bool  deny_supported (int channel_num, VortexConnection *connection, axlPointer user_data) 
{
	/* do not accept channel; never */
	return axl_false;
}

/** 
 * @internal Handler that replies to a message received with huge
 * content and then closes.
 * 
 */
void frame_received_close_after_large_reply (VortexChannel    * channel,
					     VortexConnection * connection,
					     VortexFrame      * frame,
					     axlPointer         user_data)
{
	char             * message;

	/* check message that only requires a reply followed by a message */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG &&
	    axl_cmp (vortex_frame_get_payload (frame), "send-message")) {
		printf ("Test-02d: received request to reply and send a new message..\n");
		if (! vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		if (! vortex_channel_send_msg (channel, "", 0, NULL)) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		printf ("Test-02d: received a request to reply and send a new message..ok\n");
		return;
	} /* end if */

	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Test-02d: received request, sending reply: '%s...\n", (char*) vortex_frame_get_payload (frame));
		/* send big reply */
		message = axl_new (char, 32767);
		if (! vortex_channel_send_rpy (channel, message, 32767, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		axl_free (message);

		/* wait a bit to allow sending all pending content */
		printf ("Test-02d: waiting to flush all content..\n");
		if (! vortex_channel_block_until_replies_are_sent (channel, -1)) {
			printf ("!!!!! ERROR: found error while checking if all replies were sent..\n");
			return;
		}

		/* now close the connection */
		printf ("Test-02d: sent!..now close the connection...\n");
		if (! vortex_connection_close (connection)) {
			printf ("!!!!! ERROR: failed to close connection, unable to complete test-02d..\n");
			return;
		}

		printf ("Test-02d: managed to send reply and close the connection..\n");
		return;
	} /* end if */

	printf ("Test-02d: received unhandled frame type..\n");

	return;
}

void frame_received_mime_support (VortexChannel    * channel,
				  VortexConnection * connection,
				  VortexFrame      * frame,
				  axlPointer           user_data)
{
	printf ("MIME message received (size %d): \n'%s'\n",
		vortex_frame_get_content_size (frame),
		vortex_frame_get_content (frame));

	/* before sending the content, reconfigure channel to not
	 * append CR+LF to the message */
	vortex_channel_set_automatic_mime (channel, 2);
	
	/* just echo for this moment */
	vortex_channel_send_rpy (channel,
				 vortex_frame_get_content (frame),
				 vortex_frame_get_content_size (frame),
				 vortex_frame_get_msgno (frame));
	return;
}

axl_bool ordered_delivery_message_no;

axl_bool  start_ordered_delivery (int                channel_num, 
				  VortexConnection * connection,
				  axlPointer         user_data)
{
	VortexChannel * channel;

	/* configure channel serialize */
	channel = vortex_connection_get_channel (connection, channel_num);
	vortex_channel_set_serialize (channel, axl_true);

	/* reseting message no */
	ordered_delivery_message_no = 0;

	return axl_true;
}

void frame_received_ordered_delivery (VortexChannel    * channel,
				      VortexConnection * connection,
				      VortexFrame      * frame,
				      axlPointer         user_data)
{
	VortexAsyncQueue * queue;

	vortex_channel_send_rpy (channel, "received ok", 11, vortex_frame_get_msgno (frame));

	/* implement some articifial delay */
	queue = vortex_async_queue_new ();
	vortex_async_queue_timedpop (queue, 1000);
	vortex_async_queue_unref (queue);

	if (ordered_delivery_message_no != vortex_frame_get_msgno (frame)) {
		printf ("ERROR: found different message number than expected during ordered delivery transfer (%d != %d)..\n",
			ordered_delivery_message_no, vortex_frame_get_msgno (frame));
		vortex_connection_shutdown (connection);
		return;
	} /* end if */

	/* next message to check */
	ordered_delivery_message_no++;
	return;
}

int close_channel_connection_delay = 0;

void frame_channel_connection (VortexChannel    * channel,
			       VortexConnection * connection,
			       VortexFrame      * frame,
			       axlPointer         user_data)
{
	/* check the signal to close the connection */
	if (close_channel_connection_delay == 3) {
		printf ("suddently-close(%d): close connection on receive data\n", close_channel_connection_delay);

		/* reset value */
		close_channel_connection_delay = 0;

		/* close the connection */
		vortex_connection_shutdown (connection);
	} /* end if */
}

axl_bool  frame_received_mix_replies_state = axl_false;

void      frame_received_mix_replies (VortexChannel    * channel,
				     VortexConnection * connection,
				     VortexFrame      * frame,
				     axlPointer         user_data)
{
	if (frame_received_mix_replies_state) {
		/* reply with RPY */
		printf ("Test-02k: sending RPY type...\n");
		vortex_channel_send_rpy (channel, "a reply", 7, vortex_frame_get_msgno (frame));
	} else {
		/* reply with ANS .. NUL */
		printf ("Test-02k: sending ANS..NUL type...\n");
		vortex_channel_send_ans_rpy (channel, "a reply 1", 9, vortex_frame_get_msgno (frame));
		vortex_channel_send_ans_rpy (channel, "a reply 2", 9, vortex_frame_get_msgno (frame));
		vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame));
	} /* end if */

	/* alternate replies with RPY and ANS */
	frame_received_mix_replies_state = ! frame_received_mix_replies_state;

	return;
}

void send_ans_replies_and_close (VortexChannel    * channel,
				 VortexConnection * connection,
				 VortexFrame      * frame,
				 axlPointer         user_data)
{
	int iterator = 0;

	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		/* send replies and close */
		printf ("Test 02-m: sending replies..\n");
		while (iterator < 10000) {
			/* send reply */
			if (! vortex_channel_send_ans_rpy (channel, TEST_REGRESION_URI_4_MESSAGE, strlen (TEST_REGRESION_URI_4_MESSAGE), vortex_frame_get_msgno (frame))) {
				printf ("ERROR: failed to send ANS message..closing connection..\n");
				vortex_connection_shutdown (connection);
				return;
			}

			/* next iiterator */
			iterator++;
		} /* end while */

		/* finalize send */
		printf ("Test 02-m: terminate sending with NUL frame..\n");
		if (! vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			printf ("ERROR: failed to send NUL terminating frame..closing connection..\n");
			vortex_connection_shutdown (connection);
			return; 
		} /* end if */

		/* close channel */
		printf ("Test 02-m: closing channel=%d..\n", vortex_channel_get_number (channel));
		if (! vortex_channel_close (channel, NULL)) {
			printf ("ERROR: Test 02-m: failed to close channel..\n");
			return;
		} /* end if */
		printf ("Test 02-m: channel closed..\n");

	} /* end if */


	return;
}

void frame_seqno_exceeded (VortexChannel    * channel,
			   VortexConnection * connection,
			   VortexFrame      * frame,
			   axlPointer           user_data)
{

	if (axl_cmp (vortex_frame_get_payload (frame), "first message")) {
		/* assume we have received until now 2GB - 4096 bytes = 2147479552 */
		printf ("Test 02-o: simulating content received until now: 2147479552..\n");
		/* we remove 15 from the amount of data "received"
		 * because the following function also takes into
		 * account data received until now (which is 13 bytes
		 * "first message" + 2 bytes due to MIME headers. So,
		 * to fully simulate we have received 2147479552 bytes
		 * we have to reduce the value passed to the function
		 * in 15 units. */
		vortex_channel_update_status_received (channel, (unsigned int) 2147479552 - 15, 0, UPDATE_SEQ_NO);
		vortex_channel_send_rpy (channel, "first message", 13, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_cmp (vortex_frame_get_payload (frame), "second message")) {
		/* assume we have received until now 4GB - 4096 bytes = 4294963200 */
		printf ("Test 02-o: simulating content received until now: 4294963200..\n");
		/* we have received until now: 2147479552 + 4096 + 4096 = 2147487744 
		 * So, to simulate we have received 4294963200 we need to provide the following value: 
		 * 4294963200 - 2147487744 - (20= = 2147475456 
		 * (20) value comes from: 14 + 2 ("second message" +
		 * mime headers) and 2 mime headers added to previous
		 * messages (2 +2) */
		vortex_channel_update_status_received (channel, (unsigned int) 2147475436, 0, UPDATE_SEQ_NO);
		vortex_channel_send_rpy (channel, "second message", 14, vortex_frame_get_msgno (frame));
		vortex_channel_set_max_seq_no_accepted (channel, MAX_SEQ_NO);
		return;
	} /* end if */

	/* normal message, reply same content as received */
	printf ("Test 02-o: replying same content as received..\n");
	vortex_channel_send_rpy (channel, 
				 /* payload received */
				 vortex_frame_get_payload (frame), vortex_frame_get_payload_size (frame), 
				 vortex_frame_get_msgno (frame));
	return;
}


axl_bool  start_channel_connection (int                channel_num, 
				    VortexConnection * connection,
				    axlPointer         user_data)
{

	/* check the signal to close the connection */
	if (close_channel_connection_delay == 2) {
		printf ("suddently-close(%d): close connection on start operation\n", close_channel_connection_delay);
		/* close the connection */
		vortex_connection_shutdown (connection);

		/* update indicator */
		close_channel_connection_delay++;
	} /* end if */


	return axl_true;
}

/** 
 * @internal Handler that closes the connection when received the
 * close channel request.
 */
axl_bool  close_channel_connection (int channel_num, VortexConnection * conn, axlPointer user_data)
{
	VortexAsyncQueue * queue;

	if (close_channel_connection_delay == 1) {
		printf ("suddently-close(%d): close connection with delay\n", close_channel_connection_delay);
		/* create a queue, wait and unref */
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 200000);
		vortex_async_queue_unref (queue);
	} else {
		printf ("suddently-close(%d): close connection without delay\n", close_channel_connection_delay);
	}

	/* reverse value for the next invocation */
	close_channel_connection_delay++;

	/* disconnect */
	vortex_connection_shutdown (conn);
	return axl_true;
}

int main (int  argc, char ** argv) 
{

	/* install default handling to get notification about
	 * segmentation faults */
#ifdef AXL_OS_UNIX
	signal (SIGSEGV, __block_test);
	signal (SIGABRT, __block_test);
	signal (SIGTERM,  __terminate_vortex_listener);
#endif

	vortex_mutex_create (&doing_exit_mutex);

	/* create the context */
	ctx = vortex_ctx_new ();

	/* init vortex library */
	if (! vortex_init_ctx (ctx)) {
		/* unable to init context */
		vortex_ctx_free (ctx);
		return -1;
	} /* end if */

	if (argc > 1 && 0 == strcmp (argv[1], "-v")) {
		vortex_log_enable (ctx, axl_true);
		vortex_log2_enable (ctx, axl_true);
	}

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a extended start */
	vortex_profiles_register_extended_start (ctx, REGRESSION_URI_2,
						 NULL, NULL);

	/* register more profiles */
	vortex_profiles_register (ctx, REGRESSION_URI_3,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_replies, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_4,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_replies, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_5,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_transfer_selected_file, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6,
				  /* start message */
				  check_profiles_adviced, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6bis,
				  /* start message */
				  check_profiles_adviced_bis, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ZERO,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_LISTENERS,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_BLOCK_TLS,
				  start_channel_block_tls, NULL,
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);


	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_FAST_SEND,
				  NULL, NULL,
				  NULL, NULL,
				  NULL, NULL);
	vortex_listener_set_on_connection_accepted (ctx, on_accepted_fast_send, NULL);

	vortex_profiles_register (ctx, REGRESSION_URI_DENY_SUPPORTED,
				  /* handler that always denies */
				  deny_supported, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* registre a profile to send a rpy huge and then close a channel */
	vortex_profiles_register (ctx, REGRESSION_URI_CLOSE_AFTER_LARGE_REPLY,
				  /* start channel handler */
				  NULL, NULL,
				  /* close channel handler */
				  NULL, NULL,
				  /* frame received handler */
				  frame_received_close_after_large_reply, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_MIME,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_mime_support, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ORDERED_DELIVERY,
				  start_ordered_delivery, NULL,
				  NULL, NULL,
				  frame_received_ordered_delivery, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_SUDDENTLY_CLOSE,
				  /* start channel connection which
				   * closes it on third attempt */
				  start_channel_connection, NULL,
				  /* close request where the connection is closed. */
				  close_channel_connection, NULL, 
				  /* no frame received */
				  frame_channel_connection, NULL);

	/* regiester a profile */
 	vortex_profiles_register (ctx, REGRESSION_URI_MIXING_REPLIES,
 				  /* default start and close */
 				  NULL, NULL,
 				  NULL, NULL,
 				  frame_received_mix_replies, NULL);
 

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ANS_NUL_REPLY_CLOSE,
				  /* default start, close and frame received */
				  NULL, NULL,
				  NULL, NULL,
				  NULL, NULL);
	vortex_listener_set_on_connection_accepted (ctx, on_accepted_ans_nul_reply_close, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_CLOSE_AFTER_ANS_NUL_REPLIES,
				  /* default start and close handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* frame received */
				  send_ans_replies_and_close, NULL);

	/* register nothing profile */
	vortex_profiles_register (ctx, REGRESSION_URI_NOTHING,
				  /* default start and cloes handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* default frame */
				  NULL, NULL);

	/* register nothing profile */
	vortex_profiles_register (ctx, REGRESSION_URI_SEQNO_EXCEEDED,
				  /* default start and cloes handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* default frame */
				  frame_seqno_exceeded, NULL);

	/* enable accepting incoming tls connections, this step could
	 * also be read as register the TLS profile */
	if (! vortex_tls_accept_negotiation (ctx, regression_tls_handle_query, NULL, NULL)) {
		printf ("Unable to start accepting TLS profile requests");
		return -1;
	}

	if (vortex_sasl_init (ctx)) {
		/* set default ANONYMOUS validation handler */
		vortex_sasl_set_anonymous_validation (ctx, sasl_anonymous_validation);

		/* accept SASL ANONYMOUS incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_ANONYMOUS)) {
			printf ("Unable to make Vortex Libray to accept SASL ANONYMOUS profile");
			return -1;
		}

		/* set default EXTERNAL validation handler */
		vortex_sasl_set_external_validation (ctx, sasl_external_validation);
		
		/* accept SASL EXTERNAL incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_EXTERNAL)) {
			printf ("Unable to make Vortex Libray to accept SASL EXTERNAL profile");
			return -1;
		}
		
		/* set default PLAIN validation handler */
		vortex_sasl_set_plain_validation (ctx, sasl_plain_validation);
		
		/* accept SASL PLAIN incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_PLAIN)) {
			printf ("Unable to make Vortex Libray to accept SASL PLAIN profile");
			return -1;
		}
		
		/* set default CRAM-MD5 validation handler */
		vortex_sasl_set_cram_md5_validation (ctx, sasl_cram_md5_validation);
		
		/* accept SASL CRAM-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_CRAM_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL CRAM-MD5 profile");
			return -1;
		}
		
		/* set default DIGEST-MD5 validation handler */
		vortex_sasl_set_digest_md5_validation (ctx, sasl_digest_md5_validation);
		
		/* accept SASL DIGEST-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_DIGEST_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL DIGEST-MD5 profile");
			return -1;
		} /* end if */

		/* configure default realm for all connections for the DIGEST-MD5 */
		vortex_listener_set_default_realm (ctx, "aspl.es");  

	} else {
		printf("Skipping SASL setup, since Vortex is not configured with SASL support\n");
	}
	
	/* configure support for TUNNEL profile support */
	vortex_tunnel_accept_negotiation (ctx, NULL, NULL);
	
#if defined(ENABLE_XML_RPC_SUPPORT)
	/* enable XML-RPC profile */
        vortex_xml_rpc_accept_negotiation (
		/* context */
		ctx, 
                /* no resource validation function */
                NULL,
                /* no user space data for the validation resource
		 * function. */
                NULL,
                service_dispatch,
                /* no user space data for the dispatch function. */
                NULL);
#endif

	/* configure close in transit profile */
	vortex_profiles_register (ctx, CLOSE_IN_TRANSIT_URI,
				  /* just accept all channels to be created */
				  NULL, NULL,
				  /* just accept all channels to be closed */
				  NULL, NULL,
				  close_in_transit_received, NULL);
	
	/* create a vortex server */
	vortex_listener_new (ctx, "0.0.0.0", "44010", NULL, NULL);

	/* create a vortex server to check the tunnel profile
	 * support */
	vortex_listener_new (ctx, "0.0.0.0", "44110", NULL, NULL);

	/* configure connection notification  */
	vortex_listener_set_on_connection_accepted (ctx, on_accepted, NULL);

	/* wait for listeners (until vortex_exit is called) */
	printf ("ready and waiting..\n");

	vortex_listener_wait (ctx);

	printf ("terminating the listener ..\n");

	/* terminate process */
	vortex_exit_ctx (ctx, axl_true);

	return 0;
}

