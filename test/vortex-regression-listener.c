/*
 *  LibVortex:  A BEEP (RFC3080/RFC3081) implementation.
 *  Copyright (C) 2010 Advanced Software Production Line, S.L.
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public License
 *  as published by the Free Software Foundation; either version 2.1 of
 *  the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this program; if not, write to the Free
 *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307 USA
 *  
 *  You may find a copy of the license under this software is released
 *  at COPYING file. This is LGPL software: you are welcome to
 *  develop proprietary applications using this library without any
 *  royalty or fee but returning back any change, improvement or
 *  addition in the form of source code, project image, documentation
 *  patches, etc. 
 *
 *  For commercial support on build BEEP enabled solutions contact us:
 *          
 *      Postal address:
 *         Advanced Software Production Line, S.L.
 *         C/ Antonio Suarez Nº 10, 
 *         Edificio Alius A, Despacho 102
 *         Alcalá de Henares 28802 (Madrid)
 *         Spain
 *
 *      Email address:
 *         info@aspl.es - http://www.aspl.es/vortex
 */
/* include vortex library */
#include <vortex.h>

/* include vortex tunnel support */
#include <vortex_tunnel.h>

#if defined(ENABLE_SASL_SUPPORT)
/* include sasl support */
#include <vortex_sasl.h>
#endif

#if defined(ENABLE_TLS_SUPPORT)
/* include tls support */
#include <vortex_tls.h>
#endif

/* include alive support */
#include <vortex_alive.h>

/* include source code generated by xml-rpc-gen to test xml-rpc
 * profile */
#include <service_dispatch.h>

/* include local support */
#include <vortex-regression-common.h>

#ifdef AXL_OS_UNIX
#include <signal.h>
#endif

void frame_received_fake_listeners  (VortexChannel    * channel,
				     VortexConnection * connection,
				     VortexFrame      * frame,
				     axlPointer           user_data)
{
	VortexConnection * listener;
	VortexCtx        * ctx = CONN_CTX (connection);

	/* check commands */
	if (axl_cmp (vortex_frame_get_payload (frame), "create-listener")) {
		/* create listener command received */

		printf ("RECEIVED: create-listener request..creating at 0.0.0.0:44012\n");

		/* create the listener */
		listener = vortex_listener_new (ctx, "0.0.0.0", "44012", NULL, NULL);
		if (! vortex_connection_is_ok (listener, axl_false)) {
			printf ("Test 12 (8): failed to start fake listener..\n");
			vortex_channel_send_err (channel, "failed to create listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to block listener created..\n");
		vortex_connection_block (listener, axl_true);

		/* associate listener to the channel */
		vortex_channel_set_data (channel, 
					 /* key and value */
					 "listener", listener);
		
		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener created", 16, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_cmp (vortex_frame_get_payload (frame), "unlock-listener")) {
		/* unlock listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to unlock listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to unlock listener", 25, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to unblock listener created..\n");
		vortex_connection_block (listener, axl_false);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener unblocked", 18, vortex_frame_get_msgno (frame));
		return;

	} else if (axl_cmp (vortex_frame_get_payload (frame), "close-listener")) {

		/* close listener command received */
		listener = vortex_channel_get_data (channel, "listener");
		if (listener == NULL) {
			printf ("Test 12 (9): failed to close listener, unable to find reference..\n");
			vortex_channel_send_err (channel, "failed to close listener", 24, vortex_frame_get_msgno (frame));
			return;
		} /* end if */

		printf ("CALLING: to close listener created..\n");
		vortex_listener_shutdown (listener, axl_true);

		/* reply the peer client with the same content */
		vortex_channel_send_rpy (channel, "listener closed", 15, vortex_frame_get_msgno (frame));
		return;
		
	} /* end if */

	/* default reply error */
	vortex_channel_send_err (channel,"", 0, vortex_frame_get_msgno (frame));
	return;
}

void test_01p_idle_handler (VortexCtx * ctx, VortexConnection * conn, axlPointer user_data, axlPointer user_data2)
{
	int   value = PTR_TO_INT (user_data2);
	int * count;
	if (value != 10) {
		printf ("ERROR: expected to find user_data2 = 10 but found %d, unable to complete test\n", value);
		return;
	} /* end if */
	count = (int *) user_data;
	
	/* update count */
	(*count)++;
	printf ("Test 01-p: idle handler called for connection id=%d, count=%d\n", vortex_connection_get_id (conn), *count);

	/* check initial state */
	if (PTR_TO_INT (vortex_connection_get_data (conn, "initial_accept"))) {
		printf ("Test 01-p: found idle connection at connection stage, killing..\n");
		vortex_connection_shutdown (conn);
		return;
	}

	/* check to close connection */
	/*	if ((*count) == 2)
		vortex_connection_shutdow (conn); */
	return;
}

void test_01p_remove_idle_handler (VortexConnection * connection)
{
	vortex_ctx_set_idle_handler (CONN_CTX (connection), NULL, 0, NULL, NULL);
	return;
}

axl_bool __close_connection (VortexCtx * ctx, axlPointer  user_data, axlPointer  user_data2)
{
	vortex_connection_shutdown ((VortexConnection *) user_data);
	/* request system to remove this handler once finished */
	return axl_true;
}

void frame_received (VortexChannel    * channel,
		     VortexConnection * connection,
		     VortexFrame      * frame,
		     axlPointer           user_data)
{
	int                   window_size;
	int                   bytes;
	char                * content;
	VortexPayloadFeeder * feeder;

	/* check some commands */
	if (axl_cmp (vortex_frame_get_payload (frame), "GET serverName")) {
		printf ("Received request to return serverName=%s..\n", vortex_connection_get_server_name (connection));
		
		/* reply the peer client with server name */
		vortex_channel_send_rpy (channel,
					 vortex_connection_get_server_name (connection),
					 strlen (vortex_connection_get_server_name (connection)),
					 vortex_frame_get_msgno (frame));
		return;
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "window_size=", 12)) {
		printf ("Received request to change window size to: %s..\n", 
			(char *) vortex_frame_get_payload (frame) + 12);
		window_size = atoi ((char *) vortex_frame_get_payload (frame) + 12);
		/* changing window size */
		vortex_channel_set_window_size (channel, window_size);

		/* ok reply to the peer client   */
		vortex_channel_send_rpy (channel, "ok", 2, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "count bytes: ", 13)) {
		bytes = strlen (vortex_frame_get_payload (frame) + 12);
		printf ("Content received: %s (bytes: %d)\n", (char *) (vortex_frame_get_payload (frame) + 12), bytes);
		content = axl_strdup_printf ("%d", bytes);
		vortex_channel_send_rpy (channel, content, strlen (content), vortex_frame_get_msgno (frame));
		return;
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "enable-idle-handling", 20)) {
		/* but not send more content, check if the remote side closes our connection */
		vortex_ctx_set_idle_handler (CONN_CTX (connection), test_01p_idle_handler, 1, axl_new (int, 1), INT_TO_PTR (10));

		/* uninstall idle handler when connection is removed */
		vortex_connection_set_on_close (connection, test_01p_remove_idle_handler);
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "block-connection", 16)) {
		/* lock the connection */
		vortex_connection_block (connection, axl_true);
		/* install an event handler to remove this connection between 100ms */
		vortex_thread_pool_new_event (CONN_CTX (connection), 100000, __close_connection, connection, NULL);
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "set_serial", 10)) {
		/* enable channel serialization */
		vortex_channel_set_serialize (channel, axl_true);
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "get-file-by-feeder-rpy", 22)) {
		/* create the feeder */
		feeder = vortex_payload_feeder_file ("vortex-regression-client.c", axl_true);
		
		/* send content */
		printf ("Test 04-e: sending RPY using feeder..\n");
		if (! vortex_channel_send_rpy_from_feeder (channel, feeder, vortex_frame_get_msgno (frame))) {
			printf ("ERROR: failed to send content via feeder using RPY..\n");
			return;
		} /* end if */

		return;
	} /* end if */

	/* DEFAULT REPLY, JUST ECHO */
	/* reply the peer client with the same content */
	vortex_channel_send_rpy (channel,
				 vortex_frame_get_payload (frame),
				 vortex_frame_get_payload_size (frame),
				 vortex_frame_get_msgno (frame));
	return;
}

void simple_ans_nul_reply (VortexChannel    * channel,
			   VortexConnection * connection,
			   VortexFrame      * frame,
			   axlPointer         user_data)
{
	int iterator = 0;
	int window_size; 
	VortexAsyncQueue * queue;

	if (axl_memcmp (vortex_frame_get_payload (frame), "window_size=", 12)) {
		printf ("Received request to change window size to: %s..\n", 
			(char *) vortex_frame_get_payload (frame) + 12);
		window_size = atoi ((char *) vortex_frame_get_payload (frame) + 12);
		/* changing window size */
		vortex_channel_set_window_size (channel, window_size);

		/* ok reply to the peer client   */
		vortex_channel_send_rpy (channel, "ok", 2, vortex_frame_get_msgno (frame));
		return;
	}

	printf ("%d: Replying with 30 ANS messages with a final NUL..\n", vortex_frame_get_msgno (frame));

	if (vortex_frame_get_msgno (frame) == 0) {
		/* introduce a micro delay */
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 10000);
		vortex_async_queue_unref (queue);
	}

	while (iterator < 30) {

		if (vortex_frame_get_msgno (frame) == 1 && iterator == 17) {
			/* introduce a micro delay */
			queue = vortex_async_queue_new ();
			vortex_async_queue_timedpop (queue, 10000);
			vortex_async_queue_unref (queue);
		}

		/* send ANS reply */
		vortex_channel_send_ans_rpy (channel, 
					     vortex_frame_get_payload (frame),
					     vortex_frame_get_payload_size (frame),
					     vortex_frame_get_msgno (frame));
		printf ("   %d: Sending ANS reply: %d\n", vortex_frame_get_msgno (frame), iterator);
		/* next reply */
		iterator++;
	} /* end if */
	
	/* now send nul reply */
	vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame));

	return;
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_replies (VortexChannel    * channel,
			     VortexConnection * connection,
			     VortexFrame      * frame,
			     axlPointer         user_data)
{
	VortexAsyncQueue * queue;
	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {

		vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame));
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 10000);
		vortex_async_queue_unref (queue);
		vortex_channel_send_msg (channel, "MSG###1###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###2###", 10, NULL);
		vortex_channel_send_msg (channel, "MSG###3###", 10, NULL);

	} /* end if */
	return;
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_replies (VortexChannel    * channel,
				 VortexConnection * connection,
				 VortexFrame      * frame,
				 axlPointer         user_data)
{
	int     iterator;
	int     block_size;
	int     block_num;
	char ** values;


	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);

		/* parse message received */
		values     = axl_split (vortex_frame_get_payload (frame), 1, ",");
		block_size = atoi (values[1]);
		block_num  = atoi (values[2]);
		axl_freev (values);
		printf ("Sending content (ANS/NUL test: %s, block size: %d, block num: %d)\n", 
			REGRESSION_URI_4, block_size, block_num);

		/* reply with a file (simulating it) */ 
		iterator = 0;
		
		/* send block_num messages of block_size octects  */
		while (iterator < block_num) {
			/* send the reply */
			if (!vortex_channel_send_ans_rpy (channel, 
							  /* the message reply */
							  TEST_REGRESION_URI_4_MESSAGE, block_size,
							  /* the MSG num we are replying to */
							  vortex_frame_get_msgno (frame))) {

				/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable to send ans reply\n",
					REGRESSION_URI_4);
				return;
			} /* end if */
			
			/* update iterator */
			iterator++;
		} /* end while */

		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission\n",
					REGRESSION_URI_4);
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
	} /* end if */

	return;
}

int limit_transfer_frame_size (VortexChannel *channel, int next_seq_no, int message_size, int max_seq_no, axlPointer user_data) 
{
	return VORTEX_MIN (PTR_TO_INT(user_data), VORTEX_MIN (message_size, max_seq_no - next_seq_no + 1));
}

/** 
 * @internal Frame received handler used to check wrong reply order
 * support.
 */
void frame_received_ans_transfer_selected_file (VortexChannel    * channel,
						VortexConnection * connection,
						VortexFrame      * frame,
						axlPointer         user_data)
{
	FILE * file;
	char * buffer[4096];
	int    bytes_read;
	int    total_bytes;

	/* ack message received */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {

		/* check "change-mss" message */
		if (axl_cmp (vortex_frame_get_payload (frame), "change-mss")) {
			/* request to change mss; configure the
			 * segmentator to limit transfer to tcp
			 * maximum segment size configured */
			vortex_connection_set_next_frame_size_handler (connection, 
								       limit_transfer_frame_size, INT_TO_PTR (vortex_connection_get_mss (connection) - 60));
			
			/* send reply */
			printf ("Request to change frame segmentator to up %d bytes (TCP MSS(%d) - BEEP HEADERS(60)\n",
				vortex_connection_get_mss (connection) - 60, vortex_connection_get_mss (connection));
			vortex_channel_send_rpy (channel, 
						 vortex_frame_get_payload (frame), 
						 vortex_frame_get_payload_size (frame), 
						 vortex_frame_get_msgno (frame));
			return;
		}
		
		printf ("Sending content (ANS/NUL test: %s)\n", REGRESSION_URI_5);
		/* reply with a file (simulating it) */ 
		
		file = fopen ((char *) vortex_frame_get_payload (frame), "r");
		if (file == NULL) {
			printf ("FAILED to open file: %s..\n", (char*) vortex_frame_get_payload (frame));
			vortex_channel_send_err (channel, 
						 "Unable to open file requested",
						 29, 
						 vortex_frame_get_msgno (frame));
			return;
		} /* end if */
		printf ("Sending file: %s\n", (char*) vortex_frame_get_payload (frame));
		
		/* reply the peer client with the same content 10 times */
		total_bytes = 0;
		do {
			/* read content */
			bytes_read = fread (buffer, 1, 4096, file);
			
			/* update total count */
			total_bytes += bytes_read;
			
			/* break if eof is found */
			if (bytes_read == 0) 
				break;
			
			/* printf ("Sending the reply: bytes %d..\n", bytes_read); */
			if (! vortex_channel_send_ans_rpy (channel,
							   buffer, 
							   bytes_read, 
							   vortex_frame_get_msgno (frame))) {
				fprintf (stderr, "ERROR: There was an error while sending the reply message");
				break;
				
			} /* end if */
			
		} while (axl_true);

		/* close file */
		fclose (file);
	
		/* finaly transmission */
		if (!vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			/* well, we have found an error while sending a message */
				printf ("Regression test for URI %s is failed, unable finalize ANS/NUL transmission for: %s\n",
					REGRESSION_URI_5, (char *) vortex_frame_get_payload (frame));
				return;
		} /* end if */

		printf ("Finished sending content (ANS/NUL test: %s)\n", REGRESSION_URI_4);
		
	} /* end if */

	return;
}

axl_bool      start_channel (int                channel_num, 
			     VortexConnection * connection, 
			     axlPointer           user_data)
{
	/* implement profile requirement for allowing starting a new
	 * channel to return axl_false denies channel creation to return
	 * axl_true allows create the channel */
	return axl_true;
}

axl_bool      close_channel (int                channel_num, 
			     VortexConnection * connection, 
			     axlPointer           user_data)
{
	/* implement profile requirement for allowing to closeing a
	 * the channel to return axl_false denies channel closing to
	 * return axl_true allows to close the channel */
	return axl_true;
}

axl_bool      filter_server_names (VortexConnection * connection,
				   int                channel_num,
				   const char       * uri,
				   const char       * profile_content, 
				   VortexEncoding     encoding,
				   const char       * serverName, 
				   VortexFrame      * frame,
				   char            ** error_msg, 
				   axlPointer         user_data)
{
	if (channel_num == -1)
		return axl_false; /* do not filter at greetings phase */

	if (axl_cmp (serverName, "reg-test.wrong.local")) {
		(*error_msg) = axl_strdup ("Unable to provide services under such serverName: reg-test.wrong.local");
		return axl_true; /* filter this serverName */
	}

	/* do no filter other serverNames */
	return axl_false;
}

axl_bool      on_accepted (VortexConnection * connection, axlPointer data)
{
	printf ("New connection accepted from: %s:%s\n", 
		vortex_connection_get_host (connection),
		vortex_connection_get_port (connection));

	/* configure profile mask */
	vortex_connection_set_profile_mask (connection, filter_server_names, NULL);

	/* return axl_true to accept the connection to be created */
	return axl_true;
}

axl_bool      sasl_anonymous_validation (VortexConnection * connection,
					 const char       * anonymous_token)
{
	if (axl_cmp ("test@aspl.es", anonymous_token)) {
		printf ("Received anonymous validation for: test@aspl.es, replying OK\n");
		return axl_true;
	}
	return axl_false;
}

axl_bool      sasl_external_validation (VortexConnection * connection,
					const char       * auth_id)
{
	if (axl_cmp ("acinom", auth_id)) {
		return axl_true;
	}
	
	printf ("Received external validation for: %s, replying FAILED\n", auth_id);
	return axl_false;
}

axl_bool      sasl_external_validation_full (VortexConnection * connection,
					     const char       * auth_id,
					     axlPointer         user_data)
{
	
	if (axl_cmp ("external!", (char*)user_data )) {
		return sasl_external_validation (connection, auth_id);
	}

	printf ("Received external validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.",
		 auth_id);
	return axl_false;
}



/* sasl validation handlers */
axl_bool      sasl_plain_validation  (VortexConnection * connection,
				      const char       * auth_id,
				      const char       * auth_proxy_id,
				      const char       * password)
{
	/* perform validation */
	if (axl_cmp (auth_id, "bob") && 
	    axl_cmp (password, "secret")) {
		return axl_true;
	}
	/* deny SASL request to authenticate remote peer */
	return axl_false;
}

axl_bool      sasl_plain_validation_full  (VortexConnection * connection,
					   const char       * auth_id,
					   const char       * auth_proxy_id,
					   const char       * password,
					   axlPointer user_data)
{
	if (axl_cmp ("plain!", (char*)user_data )) {
		return sasl_plain_validation (connection, auth_id, auth_proxy_id, password);
	}
	printf ("Received PLAIN validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}

char  * sasl_cram_md5_validation (VortexConnection * connection,
				  const char  * auth_id)
{
	if (axl_cmp (auth_id, "bob"))
		return axl_strdup ("secret");
	return NULL;
}

char  * sasl_cram_md5_validation_full (VortexConnection * connection,
				       const char  * auth_id,
				       axlPointer user_data)
{
	if (axl_cmp ("cram md5!", (char*)user_data )) {
		return sasl_cram_md5_validation (connection, auth_id);
	}
	printf ("Received cram md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}

char  * sasl_digest_md5_validation (VortexConnection * connection,
				    const char  * auth_id,
				    const char  * authorization_id,
				    const char  * realm)
{
	/* use the same code for the cram md5 validation */
	return sasl_cram_md5_validation (connection, auth_id);
}

char  * sasl_digest_md5_validation_full (VortexConnection * connection,
					 const char  * auth_id,
					 const char  * authorization_id,
					 const char  * realm,
					 axlPointer user_data)
{
	if (axl_cmp ("digest md5!", (char*)user_data )) {
		return sasl_digest_md5_validation (connection, auth_id, authorization_id, realm);
	}

	printf ("Received digest md5 validation (full) for: %s, replying FAILED.\nUser pointer not properly passed.", auth_id);
	return axl_false;
}

#if defined(ENABLE_SASL_SUPPORT) 
/** 
 * @internal Common SASL handler for all profiles
 */
axlPointer  common_auth_handler  (VortexConnection * conn,
				  VortexSaslProps  * props,
				  axlPointer         user_data)
{
	printf ("Received request to handle profile %s (common sasl handler)\n", props->mech);

	/* check to validate for serverName=test_06a.server */
	if (axl_cmp (props->serverName, "test_06a.server")) {
		/* check user and password */
		return INT_TO_PTR (axl_cmp (props->auth_id, "12345") && axl_cmp (props->password, "12345"));
	} /* end if */

	/* check anonymous support */
	if (axl_cmp (props->mech, VORTEX_SASL_ANONYMOUS)) {

		/* check the beacon */
		if (! axl_cmp (user_data, "anonymous beacon 123123")) {
			printf ("ERROR: expected to find anonymous beacon %s, but found %s..\n",
				(char *)user_data, "anonymous beacon 123123");
			return axl_false;
		} /* end if */

		return INT_TO_PTR (sasl_anonymous_validation (conn, props->anonymous_token));

	} else if (axl_cmp (props->mech, VORTEX_SASL_EXTERNAL)) {

		/* check the beacon */
		if (! axl_cmp ((char *)user_data, "external beacon 123123")) {
			printf ("ERROR: expected to find external beacon %s, but found %s..\n",
				(char *)user_data, "external beacon 123123");
			return axl_false;
		} /* end if */

		return INT_TO_PTR (sasl_external_validation (conn, props->authorization_id));

	} else if (axl_cmp (props->mech, VORTEX_SASL_PLAIN)) {

		/* check the beacon */
		if (! axl_cmp ((char *)user_data, "plain beacon 123123")) {
			printf ("ERROR: expected to find plain beacon %s, but found %s..\n",
				(char *)user_data, "plain beacon 123123");
			return axl_false;
		} /* end if */

		return INT_TO_PTR (sasl_plain_validation (conn, props->auth_id, props->authorization_id, props->password));

	} else if (axl_cmp (props->mech, VORTEX_SASL_CRAM_MD5)) {

		/* check the beacon */
		if (! axl_cmp ((char *)user_data, "cram-md5 beacon 123123")) {
			printf ("ERROR: expected to find cram-md5 beacon %s, but found %s..\n",
				(char *)user_data, "cram-md5 beacon 123123");
			return axl_false;
		} /* end if */

		/* signal we are returning a password */
		props->return_password = axl_true;
		return sasl_cram_md5_validation (conn, props->auth_id);

	} else if (axl_cmp (props->mech, VORTEX_SASL_DIGEST_MD5)) {

		/* check the beacon */
		if (! axl_cmp ((char *)user_data, "digest-md5 beacon 123123")) {
			printf ("ERROR: expected to find digest-md5 beacon %s, but found %s..\n",
				(char *)user_data, "digest-md5 beacon 123123");
			return axl_false;
		} /* end if */

		/* signal we are returning a password */
		props->return_password = axl_true;
		return sasl_digest_md5_validation (conn, props->auth_id, props->authorization_id, props->realm);
	}

	/* reject auth by default */
	return axl_false;
}
#endif


#ifdef AXL_OS_UNIX
void __block_test (int value) 
{
	VortexAsyncQueue * queue;

	printf ("******\n");
	printf ("****** Received a signal (the regression test is failing): pid %d..locking..!!!\n", vortex_getpid ());
	printf ("******\n");

	/* block the caller */
	queue = vortex_async_queue_new ();
	vortex_async_queue_pop (queue);

	return;
}
#endif

VortexMutex doing_exit_mutex;
axl_bool    __doing_exit = axl_false;

/* listener context */
VortexCtx * ctx = NULL;

void __terminate_vortex_listener (int value)
{
	
	vortex_mutex_lock (&doing_exit_mutex);
	if (__doing_exit) {
		vortex_mutex_unlock (&doing_exit_mutex);

		return;
	}
	printf ("Terminating vortex regression listener..\n");
	__doing_exit = axl_true;
	vortex_mutex_unlock (&doing_exit_mutex);

	/* unlocking listener */
	vortex_listener_unlock (ctx);

	return;
}

/** 
 * @brief Close in transit frame received handler. 
 */
void close_in_transit_received (VortexChannel    * channel,
				VortexConnection * conn,
				VortexFrame      * frame,
				axlPointer         user_data)
{
	/* reply to the frame received and close the channel */
	vortex_channel_send_rpy (channel,
				 "", 0, vortex_frame_get_msgno (frame));
	
	/* now close the channel */
	if (! vortex_channel_close (channel, NULL)) {
		fprintf (stderr, "FAILED TO CLOSE CHANNEL (close in transit profile)");
		return;
	}
	return;
}

/** 
 * @brief Support to check channel ready for protocols using ANS/NUL reply.
 */
void handle_ans_nul_wait (VortexChannel    * channel,
			  VortexConnection * conn,
			  VortexFrame      * frame,
			  axlPointer         user_data)
{
	VortexAsyncQueue * queue;

	/* create a queue */
	queue = vortex_async_queue_new ();

	/* send an ANS reply and wait a bit */
	vortex_channel_send_ans_rpy (channel, "this is a test..", 16, vortex_frame_get_msgno (frame));

	/* wait 30ms */
	vortex_async_queue_timedpop (queue, 130000);

	/* send an ANS reply and wait a bit */
	vortex_channel_send_ans_rpy (channel, "this is a test..2", 17, vortex_frame_get_msgno (frame));

	/* wait 40ms */
	vortex_async_queue_timedpop (queue, 140000);

	/* send an ANS reply and wait a bit */
	vortex_channel_send_ans_rpy (channel, "this is a test..3", 17, vortex_frame_get_msgno (frame));

	/* wait 50ms */
	vortex_async_queue_timedpop (queue, 150000);

	/* send an ANS reply and wait a bit */
	vortex_channel_send_ans_rpy (channel, "this is a test..3", 17, vortex_frame_get_msgno (frame));

	/* wait 60ms */
	vortex_async_queue_timedpop (queue, 140000);

	/* finally send nul reply */
	vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame));

	/* release queue */
	vortex_async_queue_unref (queue);

	return;
}
			  

axl_bool  check_profiles_adviced (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	axlList    * profiles = vortex_connection_get_remote_profiles (connection);
	int          iterator;
	const char * uri;

	
	printf ("Check profiles announced: %d\n", axl_list_length (profiles));
	iterator = 0;
	while (iterator < axl_list_length (profiles)) {
		/* get uri */
		uri = (const char *) axl_list_get_nth (profiles, iterator);
		printf ("  uri found: %s\n", uri);

		/* next position */
		iterator++;
	}  /* end while */

	if (axl_list_length (profiles) < 3) {
		printf ("ERROR: Expected to find 3 profiles registered, but found: %d..\n",
			axl_list_length (profiles));
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		axl_list_free (profiles);
		return axl_false;
	}

	/* check profiles */
	if (! vortex_connection_is_profile_supported (connection, 
						      "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		axl_list_free (profiles);
		return axl_false;
	}
	
	/* ok */
	axl_list_free (profiles);
	return axl_true;

}

axl_bool  check_profiles_adviced_bis (int channel_num, VortexConnection *connection, axlPointer user_data)
{
	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:1")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:1");
		return axl_false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:2")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n", 
			"urn:vortex:regression-test:uri:2");
		return axl_false;
	}

	/* check profiles */
	if (vortex_connection_is_profile_supported (connection, 
						    "urn:vortex:regression-test:uri:3")) {
		printf ("ERROR: Expected to find support profile: %s, but it wasn't found..\n",
			"urn:vortex:regression-test:uri:3");
		return axl_false;
	}
	
	/* return axl_true if the profile list is 0 */
	return axl_true;

}

/* a flag that allows to configure if the TLS request is accepted */
axl_bool  enable_block_tls_queries = axl_false;

axl_bool  start_channel_block_tls (int channel_num, VortexConnection * connection, axlPointer user_data)
{
	printf ("Received request to block TLS query..\n");

	/* block next tls query */
	enable_block_tls_queries = axl_true;
	return axl_true;
}

axlPointer block_ctx_creation (VortexConnection * connection, axlPointer user_data)
{
	/* simulate a failure creating the SSL context.. */
	printf ("Simulate a SSL context creation failure..\n");
	return NULL;
}

axl_bool  regression_tls_handle_query (VortexConnection * connection, const char * serverName)
{

#if defined(ENABLE_TLS_SUPPORT)
	VortexAsyncQueue * queue;

	printf ("Receiving request to start tls auth, with status=%d..\n", enable_block_tls_queries);
	if (enable_block_tls_queries) {
		/* return to not accept TLS query but revert state for
		 * the next query */
		enable_block_tls_queries = axl_false;

		/* but also configure next blocking function (to
		 * simulate a failure at the TLS protocol) */
		vortex_tls_set_ctx_creation (connection, block_ctx_creation, NULL);

		return axl_false;
	} /* end if */

	/* check for the test-05-d.server serverName to lock the
	 * listener during 10 seconds */
	if (axl_cmp (serverName, "test-05-d.server")) {
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 10000000);
		vortex_async_queue_unref (queue);
	} /* end if */

#else
	printf ("--- WARNING: Current build does not have TLS support.\n");
	return axl_false;
#endif

	return axl_true;
}

void added_channel_fast_send (VortexChannel * channel, axlPointer user_data)
{
	/* check if the channel is running the fast send profile */
	if (vortex_channel_is_running_profile (channel, REGRESSION_URI_FAST_SEND)) {
		printf ("Found channel running %s..sending two messages\n", REGRESSION_URI_FAST_SEND);
		if (! vortex_channel_send_msg (channel, "message 1", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 1 at fast send..\n");
		}

		if (! vortex_channel_send_msg (channel, "message 2", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 2 at fast send..\n");
		}
		printf ("Messages sent..ok\n");
	}
}

axl_bool  on_accepted_fast_send (VortexConnection * connection, axlPointer data)
{
	/* configure the added channel handler */
	vortex_connection_set_channel_added_handler (connection, added_channel_fast_send, NULL);

	return axl_true;
}

void added_channel_ans_nul_reply_close (VortexChannel * channel, axlPointer user_data)
{
	/* check if the channel is running the fast send profile */
	if (vortex_channel_is_running_profile (channel, REGRESSION_URI_ANS_NUL_REPLY_CLOSE)) {
		printf ("Found channel running %s..sending message\n", REGRESSION_URI_ANS_NUL_REPLY_CLOSE);

		/* send message */
		if (! vortex_channel_send_msg (channel, "message 1", 9, NULL)) {
			printf ("FAILED TO SEND MESSAGE 1 at fast send..\n");
		}		

		/* report */
		printf ("Reply sent for uri %s, 2 ANS followed by 1 NUL..\n",
			REGRESSION_URI_ANS_NUL_REPLY_CLOSE);
	} /* end if */
}


axl_bool  on_accepted_ans_nul_reply_close (VortexConnection * connection, axlPointer data)
{
	/* configure the added channel handler */
	vortex_connection_set_channel_added_handler (connection, added_channel_ans_nul_reply_close, NULL);

	return axl_true;
}


axl_bool  deny_supported (int channel_num, VortexConnection *connection, axlPointer user_data) 
{
	/* do not accept channel; never */
	return axl_false;
}

/** 
 * @internal Handler that replies to a message received with huge
 * content and then closes.
 * 
 */
void frame_received_close_after_large_reply (VortexChannel    * channel,
					     VortexConnection * connection,
					     VortexFrame      * frame,
					     axlPointer         user_data)
{
	char             * message;

	/* check message that only requires a reply followed by a message */
	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG &&
	    axl_cmp (vortex_frame_get_payload (frame), "send-message")) {
		printf ("Test-02d: received request to reply and send a new message..\n");
		if (! vortex_channel_send_rpy (channel, "", 0, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		if (! vortex_channel_send_msg (channel, "", 0, NULL)) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		printf ("Test-02d: received a request to reply and send a new message..ok\n");
		return;
	} /* end if */

	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		printf ("Test-02d: received request, sending reply: '%s...\n", (char*) vortex_frame_get_payload (frame));
		/* send big reply */
		message = axl_new (char, 32767);
		if (! vortex_channel_send_rpy (channel, message, 32767, vortex_frame_get_msgno (frame))) {
			printf ("!!!!! ERROR: found error while sending reply, unable to complete test-02d..\n");
			return;
		}
		axl_free (message);

		/* wait a bit to allow sending all pending content */
		printf ("Test-02d: waiting to flush all content..\n");
		if (! vortex_channel_block_until_replies_are_sent (channel, -1)) {
			printf ("!!!!! ERROR: found error while checking if all replies were sent..\n");
			return;
		}

		/* now close the connection */
		printf ("Test-02d: sent!..now close the connection...\n");
		if (! vortex_connection_close (connection)) {
			printf ("!!!!! ERROR: failed to close connection, unable to complete test-02d..\n");
			return;
		}

		printf ("Test-02d: managed to send reply and close the connection..\n");
		return;
	} /* end if */

	printf ("Test-02d: received unhandled frame type..\n");

	return;
}

void frame_received_mime_support (VortexChannel    * channel,
				  VortexConnection * connection,
				  VortexFrame      * frame,
				  axlPointer           user_data)
{
	printf ("MIME message received (size %d): \n'%s'\n",
		vortex_frame_get_content_size (frame),
		vortex_frame_get_content (frame));

	/* before sending the content, reconfigure channel to not
	 * append CR+LF to the message */
	vortex_channel_set_automatic_mime (channel, 2);
	
	/* just echo for this moment */
	vortex_channel_send_rpy (channel,
				 vortex_frame_get_content (frame),
				 vortex_frame_get_content_size (frame),
				 vortex_frame_get_msgno (frame));
	return;
}

axl_bool ordered_delivery_message_no;

axl_bool  start_ordered_delivery (int                channel_num, 
				  VortexConnection * connection,
				  axlPointer         user_data)
{
	VortexChannel * channel;

	/* configure channel serialize */
	channel = vortex_connection_get_channel (connection, channel_num);
	vortex_channel_set_serialize (channel, axl_true);

	/* reseting message no */
	ordered_delivery_message_no = 0;

	return axl_true;
}

void frame_received_ordered_delivery (VortexChannel    * channel,
				      VortexConnection * connection,
				      VortexFrame      * frame,
				      axlPointer         user_data)
{
	VortexAsyncQueue * queue;

	vortex_channel_send_rpy (channel, "received ok", 11, vortex_frame_get_msgno (frame));

	/* implement some articifial delay */
	queue = vortex_async_queue_new ();
	vortex_async_queue_timedpop (queue, 1000);
	vortex_async_queue_unref (queue);

	if (ordered_delivery_message_no != vortex_frame_get_msgno (frame)) {
		printf ("ERROR: found different message number than expected during ordered delivery transfer (%d != %d)..\n",
			ordered_delivery_message_no, vortex_frame_get_msgno (frame));
		vortex_connection_shutdown (connection);
		return;
	} /* end if */

	/* next message to check */
	ordered_delivery_message_no++;
	return;
}

#define FAILURE_KEY_COUNT "vo:su"

void frame_channel_connection (VortexChannel    * channel,
			       VortexConnection * connection,
			       VortexFrame      * frame,
			       axlPointer         user_data)
{
	int close_channel_connection_delay = 
		PTR_TO_INT (vortex_connection_get_data (connection, FAILURE_KEY_COUNT));

	/* check the signal to close the connection */
	if (close_channel_connection_delay == 3) {
		printf ("suddently-close(%d): close connection on receive data\n", close_channel_connection_delay);

		/* close the connection */
		vortex_connection_shutdown (connection);
	} /* end if */
}

#define MIX_REPLIES_KEY "vo:mix:rep"

void      frame_received_mix_replies (VortexChannel    * channel,
				     VortexConnection * connection,
				     VortexFrame      * frame,
				     axlPointer         user_data)
{
	axl_bool  frame_received_mix_replies_state = PTR_TO_INT (vortex_connection_get_data (connection, MIX_REPLIES_KEY));

	if (frame_received_mix_replies_state) {
		/* reply with RPY */
		printf ("Test-02k: sending RPY type...\n");
		vortex_channel_send_rpy (channel, "a reply", 7, vortex_frame_get_msgno (frame));
	} else {
		/* reply with ANS .. NUL */
		printf ("Test-02k: sending ANS..NUL type...\n");
		vortex_channel_send_ans_rpy (channel, "a reply 1", 9, vortex_frame_get_msgno (frame));
		vortex_channel_send_ans_rpy (channel, "a reply 2", 9, vortex_frame_get_msgno (frame));
		vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame));
	} /* end if */

	/* alternate replies with RPY and ANS */
	frame_received_mix_replies_state = ! frame_received_mix_replies_state;
	vortex_connection_set_data (connection, MIX_REPLIES_KEY, INT_TO_PTR (frame_received_mix_replies_state));

	return;
}

void send_ans_replies_and_close (VortexChannel    * channel,
				 VortexConnection * connection,
				 VortexFrame      * frame,
				 axlPointer         user_data)
{
	int iterator = 0;

	if (vortex_frame_get_type (frame) == VORTEX_FRAME_TYPE_MSG) {
		/* send replies and close */
		printf ("Test 02-m: sending replies..\n");
		while (iterator < 10000) {
			/* send reply */
			if (! vortex_channel_send_ans_rpy (channel, TEST_REGRESION_URI_4_MESSAGE, strlen (TEST_REGRESION_URI_4_MESSAGE), vortex_frame_get_msgno (frame))) {
				printf ("ERROR: failed to send ANS message..closing connection..\n");
				vortex_connection_shutdown (connection);
				return;
			}

			/* next iiterator */
			iterator++;
		} /* end while */

		/* finalize send */
		printf ("Test 02-m: terminate sending with NUL frame..\n");
		if (! vortex_channel_finalize_ans_rpy (channel, vortex_frame_get_msgno (frame))) {
			printf ("ERROR: failed to send NUL terminating frame..closing connection..\n");
			vortex_connection_shutdown (connection);
			return; 
		} /* end if */

		/* close channel */
		printf ("Test 02-m: closing channel=%d..\n", vortex_channel_get_number (channel));
		if (! vortex_channel_close (channel, NULL)) {
			printf ("ERROR: Test 02-m: failed to close channel..\n");
			return;
		} /* end if */
		printf ("Test 02-m: channel closed..\n");

	} /* end if */


	return;
}

void frame_seqno_exceeded (VortexChannel    * channel,
			   VortexConnection * connection,
			   VortexFrame      * frame,
			   axlPointer           user_data)
{
	long value;

	if (axl_cmp (vortex_frame_get_payload (frame), "first message")) {
		/* assume we have received until now 2GB - 4096 bytes = 2147479552 */
		printf ("Test 02-o: simulating content received until now: 2147479552..\n");
		/* we remove 15 from the amount of data "received"
		 * because the following function also takes into
		 * account data received until now (which is 13 bytes
		 * "first message" + 2 bytes due to MIME headers. So,
		 * to fully simulate we have received 2147479552 bytes
		 * we have to reduce the value passed to the function
		 * in 15 units. */
		vortex_channel_update_status_received (channel, (unsigned int) 2147479552 - 15, 0, UPDATE_SEQ_NO);
		vortex_channel_set_max_seq_no_accepted (channel, (unsigned int) 2147479552, 4096);
		vortex_channel_send_rpy (channel, "first message", 13, vortex_frame_get_msgno (frame));
		return;
	} else if (axl_cmp (vortex_frame_get_payload (frame), "second message")) {
		/* assume we have received until now 4GB - 4096 bytes = 4294963200 */
		printf ("Test 02-o: simulating content received until now: 4294963200..\n");
		/* we have received until now: 2147479552 + 4096 + 4096 = 2147487744 
		 * So, to simulate we have received 4294963200 we need to provide the following value: 
		 * 4294963200 - 2147487744 - (20= = 2147475456 
		 * (20) value comes from: 14 + 2 ("second message" +
		 * mime headers) and 2 mime headers added to previous
		 * messages (2 +2) */
		vortex_channel_update_status_received (channel, (unsigned int) 2147475436, 0, UPDATE_SEQ_NO);
		vortex_channel_send_rpy (channel, "second message", 14, vortex_frame_get_msgno (frame));
		vortex_channel_set_max_seq_no_accepted (channel, MAX_SEQ_NO - 4095, 4096);
		return;
	} else if (axl_memcmp (vortex_frame_get_payload (frame), "set-to=", 7)) {
		value = atol (vortex_frame_get_payload (frame) + 7);
		printf ("Test 02-o: setting received content until now to: %ld\n", value);

		vortex_channel_update_status_received (channel, (unsigned int) value, 0, UPDATE_SEQ_NO);
		vortex_channel_set_max_seq_no_accepted (channel, value, 4096);

	} /* end if */

	/* normal message, reply same content as received */
	printf ("Test 02-o: replying same content as received..\n");
	vortex_channel_send_rpy (channel, 
				 /* payload received */
				 vortex_frame_get_payload (frame), vortex_frame_get_payload_size (frame), 
				 vortex_frame_get_msgno (frame));
	return;
}


axl_bool  start_suddently_closed (
	const char       * profile,
	int                channel_num, 
	VortexConnection * connection,
	const char       * serverName,
	const char       * profile_content,
	char            ** profile_reply,
	VortexEncoding     encoding,
	axlPointer         user_data)
{
	/* get received configuration */
	int close_channel_connection_delay = 0;

	if (profile_content != NULL) {
		/* get failure count configuration */
		close_channel_connection_delay = atoi (profile_content);

		printf ("Connection delay failure: %d..\n", close_channel_connection_delay);
		vortex_connection_set_data (connection, FAILURE_KEY_COUNT, INT_TO_PTR (close_channel_connection_delay));

	} /* end if */

	/* check the signal to close the connection */
	if (close_channel_connection_delay == 2) {
		printf ("suddently-close(%d): close connection on start operation\n", close_channel_connection_delay);
		/* close the connection */
		vortex_connection_shutdown (connection);
	} /* end if */


	return axl_true;
}

/** 
 * @internal Handler that closes the connection when received the
 * close channel request.
 */
axl_bool  close_channel_connection (int channel_num, VortexConnection * conn, axlPointer user_data)
{
	VortexAsyncQueue * queue;

	int close_channel_connection_delay = 
		PTR_TO_INT (vortex_connection_get_data (conn, FAILURE_KEY_COUNT));

	if (close_channel_connection_delay == 1) {
		printf ("suddently-close(%d): close connection with delay\n", close_channel_connection_delay);
		/* create a queue, wait and unref */
		queue = vortex_async_queue_new ();
		vortex_async_queue_timedpop (queue, 200000);
		vortex_async_queue_unref (queue);
	} else {
		printf ("suddently-close(%d): close connection without delay\n", close_channel_connection_delay);
	}

	/* disconnect */
	vortex_connection_shutdown (conn);
	return axl_true;
}

int process_greetings_features (VortexCtx               * ctx, 
				VortexConnection        * conn,
				VortexConnection       ** new_conn,
				VortexConnectionStage     stage,
				axlPointer                user_data)
{
	/* still unused */
	return 0;
}

int main (int  argc, char ** argv) 
{
	VortexConnection * listener;
#if defined(ENABLE_SASL_SUPPORT)
	VortexCtx        * ctx2;
#endif

	/* install default handling to get notification about
	 * segmentation faults */
#ifdef AXL_OS_UNIX
	signal (SIGSEGV, __block_test);
	signal (SIGABRT, __block_test);
	signal (SIGTERM,  __terminate_vortex_listener);
#endif

	vortex_mutex_create (&doing_exit_mutex);

	/* create the context */
	ctx = vortex_ctx_new ();

	/* init vortex library */
	if (! vortex_init_ctx (ctx)) {
		/* unable to init context */
		vortex_ctx_free (ctx);
		return -1;
	} /* end if */

	if (argc > 1 && 0 == strcmp (argv[1], "-v")) {
		vortex_log_enable (ctx, axl_true);
		vortex_log2_enable (ctx, axl_true);
	}

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a extended start */
	vortex_profiles_register_extended_start (ctx, REGRESSION_URI_2,
						 NULL, NULL);

	/* register more profiles */
	vortex_profiles_register (ctx, REGRESSION_URI_3,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_replies, NULL);

	/* register profile to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_SIMPLE_ANS_NUL,
				  NULL, NULL,
				  NULL, NULL,
				  simple_ans_nul_reply, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_4,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_replies, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_5,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_ans_transfer_selected_file, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6,
				  /* start message */
				  check_profiles_adviced, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register the profile used to test ANS/NUL replies */
	vortex_profiles_register (ctx, REGRESSION_URI_6bis,
				  /* start message */
				  check_profiles_adviced_bis, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ZERO,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_LISTENERS,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_BLOCK_TLS,
				  start_channel_block_tls, NULL,
				  NULL, NULL,
				  frame_received_fake_listeners, NULL);


	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_FAST_SEND,
				  NULL, NULL,
				  NULL, NULL,
				  NULL, NULL);
	vortex_listener_set_on_connection_accepted (ctx, on_accepted_fast_send, NULL);

	vortex_profiles_register (ctx, REGRESSION_URI_DENY_SUPPORTED,
				  /* handler that always denies */
				  deny_supported, NULL,
				  NULL, NULL,
				  NULL, NULL);

	/* registre a profile to send a rpy huge and then close a channel */
	vortex_profiles_register (ctx, REGRESSION_URI_CLOSE_AFTER_LARGE_REPLY,
				  /* start channel handler */
				  NULL, NULL,
				  /* close channel handler */
				  NULL, NULL,
				  /* frame received handler */
				  frame_received_close_after_large_reply, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_MIME,
				  NULL, NULL, 
				  NULL, NULL,
				  frame_received_mime_support, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ORDERED_DELIVERY,
				  start_ordered_delivery, NULL,
				  NULL, NULL,
				  frame_received_ordered_delivery, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_SUDDENTLY_CLOSE,
				  /* no start handler */
				  NULL, NULL,
				  /* close request where the connection is closed. */
				  close_channel_connection, NULL, 
				  /* no frame received */
				  frame_channel_connection, NULL);

	vortex_profiles_register_extended_start (ctx, REGRESSION_URI_SUDDENTLY_CLOSE,
						 /* start channel extended handler */
						 start_suddently_closed, NULL);

	/* regiester a profile */
 	vortex_profiles_register (ctx, REGRESSION_URI_MIXING_REPLIES,
 				  /* default start and close */
 				  NULL, NULL,
 				  NULL, NULL,
 				  frame_received_mix_replies, NULL);
 

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_ANS_NUL_REPLY_CLOSE,
				  /* default start, close and frame received */
				  NULL, NULL,
				  NULL, NULL,
				  NULL, NULL);
	vortex_listener_set_on_connection_accepted (ctx, on_accepted_ans_nul_reply_close, NULL);

	/* register a profile */
	vortex_profiles_register (ctx, REGRESSION_URI_CLOSE_AFTER_ANS_NUL_REPLIES,
				  /* default start and close handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* frame received */
				  send_ans_replies_and_close, NULL);

	/* register nothing profile */
	vortex_profiles_register (ctx, REGRESSION_URI_NOTHING,
				  /* default start and cloes handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* default frame */
				  NULL, NULL);

	/* register nothing profile */
	vortex_profiles_register (ctx, REGRESSION_URI_SEQNO_EXCEEDED,
				  /* default start and cloes handlers */
				  NULL, NULL,
				  NULL, NULL,
				  /* default frame */
				  frame_seqno_exceeded, NULL);

	/* check x-serverName on greetings support */
	vortex_connection_set_connection_actions (ctx, CONNECTION_STAGE_PROCESS_GREETINGS_FEATURES, 
						  process_greetings_features, NULL);

	/* enable alive profile */
	vortex_alive_init (ctx);

#if defined(ENABLE_TLS_SUPPORT)
	/* enable accepting incoming tls connections, this step could
	 * also be read as register the TLS profile */
	if (! vortex_tls_accept_negotiation (ctx, regression_tls_handle_query, NULL, NULL)) {
		printf ("Unable to start accepting TLS profile requests");
		return -1;
	}
#else
	printf ("--- WARNING: Current build does not have TLS support.\n");
#endif

#if defined(ENABLE_SASL_SUPPORT)
	if (vortex_sasl_init (ctx)) {
		/* set default ANONYMOUS validation handler */
		vortex_sasl_set_anonymous_validation (ctx, sasl_anonymous_validation);

		/* accept SASL ANONYMOUS incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_ANONYMOUS)) {
			printf ("Unable to make Vortex Libray to accept SASL ANONYMOUS profile");
			return -1;
		}

		/* set default EXTERNAL validation handler */
		vortex_sasl_set_external_validation (ctx, sasl_external_validation);
		
		/* accept SASL EXTERNAL incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_EXTERNAL)) {
			printf ("Unable to make Vortex Libray to accept SASL EXTERNAL profile");
			return -1;
		}
		
		/* set default PLAIN validation handler */
		vortex_sasl_set_plain_validation (ctx, sasl_plain_validation);
		
		/* accept SASL PLAIN incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_PLAIN)) {
			printf ("Unable to make Vortex Libray to accept SASL PLAIN profile");
			return -1;
		}
		
		/* set default CRAM-MD5 validation handler */
		vortex_sasl_set_cram_md5_validation (ctx, sasl_cram_md5_validation);
		
		/* accept SASL CRAM-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_CRAM_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL CRAM-MD5 profile");
			return -1;
		}
		
		/* set default DIGEST-MD5 validation handler */
		vortex_sasl_set_digest_md5_validation (ctx, sasl_digest_md5_validation);
		
		/* accept SASL DIGEST-MD5 incoming requests */
		if (! vortex_sasl_accept_negotiation (ctx, VORTEX_SASL_DIGEST_MD5)) {
			printf ("Unable to make Vortex Library to accept SASL DIGEST-MD5 profile");
			return -1;
		} /* end if */

		/* configure default realm for all connections for the DIGEST-MD5 */
		vortex_listener_set_default_realm (ctx, "aspl.es");  

	}
#else
	printf("--- WARNING: Skipping SASL setup, since Vortex is not configured with SASL support\n");
#endif	
	/* configure support for TUNNEL profile support */
	vortex_tunnel_accept_negotiation (ctx, NULL, NULL);
	
#if defined(ENABLE_XML_RPC_SUPPORT)
	/* enable XML-RPC profile */
        vortex_xml_rpc_accept_negotiation (
		/* context */
		ctx, 
                /* no resource validation function */
                NULL,
                /* no user space data for the validation resource
		 * function. */
                NULL,
                service_dispatch,
                /* no user space data for the dispatch function. */
                NULL);
#endif

	/* configure close in transit profile */
	vortex_profiles_register (ctx, CLOSE_IN_TRANSIT_URI,
				  /* just accept all channels to be created */
				  NULL, NULL,
				  /* just accept all channels to be closed */
				  NULL, NULL,
				  close_in_transit_received, NULL);

	vortex_profiles_register (ctx, REGRESSION_URI_ANS_NUL_WAIT,
				  /* accept all channels to be created */
				  NULL, NULL,
				  /* accept all channels to be closed */
				  NULL, NULL,
				  handle_ans_nul_wait, NULL);
				  
				  
	
	/* create a vortex server */
	listener = vortex_listener_new (ctx, "0.0.0.0", "44010", NULL, NULL);
	if (! vortex_connection_is_ok (listener, axl_false)) {
		printf ("ERROR: failed to start listener at: 44010, error found (code: %d): %s\n",
			vortex_connection_get_status (listener),
			vortex_connection_get_message (listener));
		return -1;
	}

	/* create a vortex server to check the tunnel profile
	 * support */
	listener = vortex_listener_new (ctx, "0.0.0.0", "44110", NULL, NULL);
	if (! vortex_connection_is_ok (listener, axl_false)) {
		printf ("ERROR: failed to start listener at: 44110, error found (code: %d): %s\n",
			vortex_connection_get_status (listener),
			vortex_connection_get_message (listener));
		return -1;
	}

	/* run also on 443 port to allow receiving http connect
	 * request */
	listener = vortex_listener_new (ctx, "0.0.0.0", "443", NULL, NULL);
	if (! vortex_connection_is_ok (listener, axl_false)) {
		printf ("ERROR: failed to start listener at: 443, error found (code: %d): %s\n",
			vortex_connection_get_status (listener),
			vortex_connection_get_message (listener));
		return -1;
	}

#if defined(ENABLE_SASL_SUPPORT)
	/* run also on 44011 to test unified SASL handling */
	ctx2 = vortex_ctx_new ();
	if (! vortex_init_ctx (ctx2)) {
		printf ("ERROR: failed to init vortex ctx object required to check unified SASL API..\n");
		return -1;
	}
	/* enable sasl */
	if (! vortex_sasl_init (ctx2)) {
		printf ("ERROR: failed to init SASL to check unified API..\n");
		return -1;
	} /* end if */

	listener = vortex_listener_new (ctx2, "0.0.0.0", "44011", NULL, NULL);
	if (! vortex_connection_is_ok (listener, axl_false)) {
		printf ("ERROR: failed to start listener at: 44011, error found (code: %d): %s\n",
			vortex_connection_get_status (listener),
			vortex_connection_get_message (listener));
		return -1;
	}

	/* configure the handler */
	if (! vortex_sasl_accept_negotiation_common (ctx2, VORTEX_SASL_ANONYMOUS, common_auth_handler, "anonymous beacon 123123")) {
		printf ("ERROR: Failed to register anonymous profile using common api..\n");
		return -1;
	}

	if (! vortex_sasl_accept_negotiation_common (ctx2, VORTEX_SASL_PLAIN, common_auth_handler, "plain beacon 123123")) {
		printf ("ERROR: Failed to register plain profile using common api..\n");
		return -1;
	}

	if (! vortex_sasl_accept_negotiation_common (ctx2, VORTEX_SASL_EXTERNAL, common_auth_handler, "external beacon 123123")) {
		printf ("ERROR: Failed to register external profile using common api..\n");
		return -1;
	}

	if (! vortex_sasl_accept_negotiation_common (ctx2, VORTEX_SASL_CRAM_MD5, common_auth_handler, "cram-md5 beacon 123123")) {
		printf ("ERROR: Failed to register cram-md5 profile using common api..\n");
		return -1;
	}

	if (! vortex_sasl_accept_negotiation_common (ctx2, VORTEX_SASL_DIGEST_MD5, common_auth_handler, "digest-md5 beacon 123123")) {
		printf ("ERROR: Failed to register digest-md5 profile using common api..\n");
		return -1;
	}

#else
	printf("--- WARNING: Skipping SASL unified API check, since Vortex is not configured with SASL support\n");
#endif

	/* configure connection notification  */
	vortex_listener_set_on_connection_accepted (ctx, on_accepted, NULL);

	/* wait for listeners (until vortex_exit is called) */
	printf ("ready and waiting..\n");

	vortex_listener_wait (ctx);

	printf ("terminating the listener ..\n");

	/* terminate process */
	vortex_exit_ctx (ctx, axl_true);
#if defined(ENABLE_SASL_SUPPORT)
	vortex_exit_ctx (ctx2, axl_true);
#endif

	return 0;
}

