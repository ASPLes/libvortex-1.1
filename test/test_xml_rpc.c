/**
 * C client stub to invoke services exported by the XML-RPC component: test.
 *
 * This file was generated by xml-rpc-gen tool, from Vortex Library
 * project.
 *
 * Vortex Library homepage: http://vortex.aspl.es
 * Axl Library homepage: http://xml.aspl.es
 * Advanced Software Production Line: http://www.aspl.es
 */
#include <test_xml_rpc.h>

XmlRpcMethodCall * __common_sum_int_int (VortexCtx * _ctx_, int a, int b)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "sum", 2);

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (a));

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (b));

	/* return invocator created */
	return _invocator_;
}

/* service: sum */
int test_sum_int_int_s (int a, int b, VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_sum_int_int (_ctx_, a, b);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_int_sync  (_response_, status, channel, fault_code, fault_string);
}

void test_sum_int_int (int a, int b, VortexChannel * channel, XmlRpcProcessInt process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_sum_int_int (_ctx_, a, b);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_int, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_operate_int_int (VortexCtx * _ctx_, int a, int b)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "operate", 2);

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (a));

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (b));

	/* return invocator created */
	return _invocator_;
}

/* service: operate */
int test_operate_int_int_s (int a, int b, VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_operate_int_int (_ctx_, a, b);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_int_sync  (_response_, status, channel, fault_code, fault_string);
}

void test_operate_int_int (int a, int b, VortexChannel * channel, XmlRpcProcessInt process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_operate_int_int (_ctx_, a, b);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_int, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_the_string (VortexCtx * _ctx_)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_the_string", 0);

	/* return invocator created */
	return _invocator_;
}

/* service: get_the_string */
char * test_get_the_string_s (VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_string (_ctx_);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_string_sync  (_response_, status, channel, fault_code, fault_string);
}

void test_get_the_string (VortexChannel * channel, XmlRpcProcessString process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_string (_ctx_);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_string, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_the_bool_1 (VortexCtx * _ctx_)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_the_bool_1", 0);

	/* return invocator created */
	return _invocator_;
}

/* service: get_the_bool_1 */
axl_bool test_get_the_bool_1_s (VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_bool_1 (_ctx_);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_int_sync  (_response_, status, channel, fault_code, fault_string) == axl_true;
}

void test_get_the_bool_1 (VortexChannel * channel, XmlRpcProcessInt process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_bool_1 (_ctx_);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_int, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_the_bool_2 (VortexCtx * _ctx_)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_the_bool_2", 0);

	/* return invocator created */
	return _invocator_;
}

/* service: get_the_bool_2 */
axl_bool test_get_the_bool_2_s (VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_bool_2 (_ctx_);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_int_sync  (_response_, status, channel, fault_code, fault_string) == axl_true;
}

void test_get_the_bool_2 (VortexChannel * channel, XmlRpcProcessInt process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_the_bool_2 (_ctx_);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_int, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_double_sum_double_double (VortexCtx * _ctx_, double a, double b)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_double_sum", 2);

	method_call_create_value (_invocator_, XML_RPC_DOUBLE_VALUE, &a);

	method_call_create_value (_invocator_, XML_RPC_DOUBLE_VALUE, &b);

	/* return invocator created */
	return _invocator_;
}

/* service: get_double_sum */
double test_get_double_sum_double_double_s (double a, double b, VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_double_sum_double_double (_ctx_, a, b);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_double_sync  (_response_, status, channel, fault_code, fault_string);
}

void test_get_double_sum_double_double (double a, double b, VortexChannel * channel, XmlRpcProcessDouble process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_double_sum_double_double (_ctx_, a, b);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_double, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_struct_values_values (VortexCtx * _ctx_, Values * a, Values * b)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_struct", 2);

	method_call_create_value (_invocator_, XML_RPC_STRUCT_VALUE, test_values_marshall (_ctx_, a, axl_false));

	method_call_create_value (_invocator_, XML_RPC_STRUCT_VALUE, test_values_marshall (_ctx_, b, axl_false));

	/* return invocator created */
	return _invocator_;
}

/* service: get_struct */
Values * test_get_struct_values_values_s (Values * a, Values * b, VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_struct_values_values (_ctx_, a, b);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_struct_sync  (_response_, (XmlRpcStructUnMarshaller) test_values_unmarshall, status, channel, fault_code, fault_string);
}

void test_get_struct_values_values (Values * a, Values * b, VortexChannel * channel, XmlRpcProcessStruct process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_struct_values_values (_ctx_, a, b);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_struct, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_array (VortexCtx * _ctx_)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_array", 0);

	/* return invocator created */
	return _invocator_;
}

/* service: get_array */
ItemArray * test_get_array_s (VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_array (_ctx_);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_array_sync  (_response_, (XmlRpcArrayUnMarshaller) test_itemarray_unmarshall, status, channel, fault_code, fault_string);
}

void test_get_array (VortexChannel * channel, XmlRpcProcessArray process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_array (_ctx_);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_array, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_get_list (VortexCtx * _ctx_)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "get_list", 0);

	/* return invocator created */
	return _invocator_;
}

/* service: get_list */
Node * test_get_list_s (VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_list (_ctx_);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_struct_sync  (_response_, (XmlRpcStructUnMarshaller) test_node_unmarshall, status, channel, fault_code, fault_string);
}

void test_get_list (VortexChannel * channel, XmlRpcProcessStruct process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_get_list (_ctx_);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_struct, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

XmlRpcMethodCall * __common_sum2_int_int (VortexCtx * _ctx_, int a, int b)
{
	XmlRpcMethodCall * _invocator_;

	/* create the method call invocator */
	_invocator_ = method_call_new (_ctx_, "aritmetic-operations/basic/sum", 2);

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (a));

	method_call_create_value (_invocator_, XML_RPC_INT_VALUE, INT_TO_PTR (b));

	/* return invocator created */
	return _invocator_;
}

/* service: sum2 */
int test_sum2_int_int_s (int a, int b, VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)
{
	XmlRpcMethodCall     * _invocator_;
	XmlRpcMethodResponse * _response_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_sum2_int_int (_ctx_, a, b);

	/* perform the invocation, in a synchronous way, get blocked
	 * until it is received */
	_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);

	/* unmarshall sync result */
	return vortex_xml_rpc_unmarshall_int_sync  (_response_, status, channel, fault_code, fault_string);
}

void test_sum2_int_int (int a, int b, VortexChannel * channel, XmlRpcProcessInt process)
{

	XmlRpcMethodCall     * _invocator_;
	VortexCtx            * _ctx_ = CHANNEL_CTX(channel);

	/* create the XmlRpcMethodCall object */
	_invocator_ = __common_sum2_int_int (_ctx_, a, b);

	/* perform invocation, passing an unmarshall function that
	 * receives the int value and the handler from the user
	 * space */
	 vortex_xml_rpc_invoke (channel, _invocator_, vortex_xml_rpc_unmarshall_int, process);

	/* nothing more to do: the invocator and values added are not
	 * required to be released because they are deallocated by the
	 * invocator engine. */
	return;
}

