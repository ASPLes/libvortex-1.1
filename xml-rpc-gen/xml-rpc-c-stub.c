/* Hey emacs, show me this like 'c': -*- c -*-
 *
 * xml-rpc-gen: a protocol compiler for the XDL definition language
 * Copyright (C) 2010 Advanced Software Production Line, S.L.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 */

#include <xml-rpc-c-stub.h>

/** 
 * @internal
 *
 * Writes the stub header.
 */
void xml_rpc_source_write_header (char  * comp_name)
{
	/* write the source header */
	xml_rpc_support_write ("/**\n * C client stub to invoke services exported by the XML-RPC component: %s.\n *\n",
			       comp_name);
	/* write the rest of lines */
	xml_rpc_support_multiple_write (" * This file was generated by xml-rpc-gen tool, from Vortex Library\n",
					" * project.\n",
					" *\n",
					" * Vortex Library homepage: http://vortex.aspl.es\n", 
					" * Axl Library homepage: http://xml.aspl.es\n",
					" * Advanced Software Production Line: http://www.aspl.es\n",
					" */\n", NULL);
	/* finish */
	return;
}

/** 
 * @internal
 *
 * Writes the function type prefix, assuming that the reference
 * received is pointing to the <params>.
 * 
 * @param aux 
 */
void xml_rpc_support_write_function_type_prefix (axlNode * params)
{
	axlNode * aux2;
	axlNode * aux3;	

	char    * type;
	char    * type_ref;

	/* now we have int aux a reference to the <params> node, get
	 * its first child */
	if (axl_node_have_childs (params)) {
		/* the params node have childs, which means the
		 * service have parameters */
		aux2 = axl_node_get_child_nth (params, 0);
		do {
			/* get a reference to the type node */
			aux3 = axl_node_get_child_nth (aux2, 1);
			
			/* get the type */
			type     = axl_node_get_content_trim (aux3, NULL);
			type_ref = xml_rpc_support_to_lower (type);

			/* write type found */
			xml_rpc_support_sl_write ("_%s", type_ref);

			axl_free (type_ref);
			
		}while ((aux2 = axl_node_get_next (aux2)) != NULL);
	}
	
	/* no more type parameter */
	return;
}

/** 
 * @internal
 *
 * Writes the parameter function assuming that the node receives is
 * pointing to the <params> node.
 * 
 */
void xml_rpc_support_write_function_parameters (axlDoc * doc, axlNode * params)
{

	axlNode * aux2;
	axlNode * aux3;	

	char    * type;
	char    * name;

	axl_bool  first = axl_true;

	/* now write the service parameter spec */
	if (axl_node_have_childs (params)) {
		
		/* the params node have childs, which means the
		 * service have parameters */
		aux2 = axl_node_get_child_nth (params, 0);
		do {
			/* get a reference to the type node */
			aux3 = axl_node_get_child_nth (aux2, 1);
			
			/* get the type */
			type = axl_node_get_content_trim (aux3, NULL);

			if (! first) 
				xml_rpc_support_sl_write (", ");
			first = axl_false;

			/* write type found */
			if (xml_rpc_c_stub_type_is_struct (doc, type) ||
			    xml_rpc_c_stub_type_is_array (doc, type)) 
				xml_rpc_support_sl_write ("%s * ", type);
			else if (axl_cmp (type, "string"))
				xml_rpc_support_sl_write ("const char * ");
			else if (axl_cmp (type, "bool"))
				xml_rpc_support_sl_write ("int ");
			else
				xml_rpc_support_sl_write ("%s ", type);

			/* get the parameter name */
			aux3 = axl_node_get_child_nth (aux2, 0);
			
			/* get the name */
			name = axl_node_get_content_trim (aux3, NULL);

			/* write the parameter name */
			xml_rpc_support_sl_write ("%s", name);
			
		}while ((aux2 = axl_node_get_next (aux2)) != NULL);
	}

	/* nothing more */
	return;
}

/** 
 * @internal
 * 
 * Write parameter names for a service params node that is pointed by
 * the axlNode received.
 *
 * @param aux 
 */
void xml_rpc_support_write_function_parameters_names (axlNode * aux)
{
	axlNode * aux2;
	axlNode * aux3;	

	char    * name;
	axl_bool  first = axl_true;

	/* now write the service parameter spec */
	if (axl_node_have_childs (aux)) {
		
		/* the params node have childs, which means the
		 * service have parameters */
		aux2 = axl_node_get_child_nth (aux, 0);
		do {
			/* get a reference to the type node */
			aux3 = axl_node_get_child_nth (aux2, 0);
			
			/* get the type */
			name = axl_node_get_content_trim (aux3, NULL);

			if (! first) 
				xml_rpc_support_sl_write (", ");
			first = axl_false;

			/* write type found */
			xml_rpc_support_sl_write ("%s", name);

		}while ((aux2 = axl_node_get_next (aux2)) != NULL);
	}

	/* nothing more */
	return;
}

/** 
 * @internal
 *
 * Writes to the stub body file the method call create value
 * instructions.
 * 
 * @param aux The \ref axlNode reference pointing to the params value.
 */
void xml_rpc_support_write_method_create_values (axlDoc * doc, axlNode * aux, char  * comp_name)
{

	axlNode * aux2;
	axlNode * aux3;	

	char    * type;
	char    * type_ref;
	char    * name;

	char    * comp_name_lower;

	/* now write the service parameter spec */
	if (axl_node_have_childs (aux)) {
		
		/* the params node have childs, which means the
		 * service have parameters */
		aux2 = axl_node_get_child_nth (aux, 0);
		do {
			/* get a reference to the type node */
			aux3 = axl_node_get_child_nth (aux2, 1);
			
			/* get the type */
			type = axl_node_get_content_trim (aux3, NULL);

			/* get the parameter name */
			aux3 = axl_node_get_child_nth (aux2, 0);
			
			/* get the name */
			name     = axl_node_get_content_trim (aux3, NULL);

			type_ref = xml_rpc_support_to_upper (type);

			/* write the parameter name */
			if (xml_rpc_c_stub_type_is_struct (doc, type))
				xml_rpc_support_write ("method_call_create_value (_invocator_, XML_RPC_STRUCT_VALUE, ");
			else if (xml_rpc_c_stub_type_is_array (doc, type))
				xml_rpc_support_write ("method_call_create_value (_invocator_, XML_RPC_ARRAY_VALUE, ");
			else if (axl_cmp (type, "string")) 
				xml_rpc_support_write ("method_call_create_value (_invocator_, XML_RPC_%s_VALUE, (char *) ", type_ref);
			else if (axl_cmp (type, "bool")) 
				xml_rpc_support_write ("method_call_create_value (_invocator_, XML_RPC_BOOLEAN_VALUE, ");
			else 
				xml_rpc_support_write ("method_call_create_value (_invocator_, XML_RPC_%s_VALUE, ", type_ref);
			
			/* release type ref allocated */
			axl_free (type_ref);

			/* write int and bool */
			if (axl_cmp (type, "int") || 
			    axl_cmp (type, "bool"))
				xml_rpc_support_sl_write ("INT_TO_PTR (%s)", name);
			
			/* write string, base64, array and struct */
			if (axl_cmp (type, "string") || 
			    axl_cmp (type, "base64") ||
			    axl_cmp (type, "array") ||
			    axl_cmp (type, "struct"))
				xml_rpc_support_sl_write ("%s", name);

			/* write the double case */
			if (axl_cmp (type, "double"))
				xml_rpc_support_sl_write ("&%s", name);

			/* write the parameter name */
			if (xml_rpc_c_stub_type_is_struct (doc, type) ||
			    xml_rpc_c_stub_type_is_array (doc, type)) {
				/* allocate lower names */
				comp_name_lower = xml_rpc_support_to_lower (comp_name);
				type_ref        = xml_rpc_support_to_lower (type);

				/* write marshaller line */
				xml_rpc_support_sl_write ("%s_%s_marshall (_ctx_, %s, axl_false)",
						       comp_name_lower, type_ref, name);

				/* deallocate memory for lower names */
				axl_free (type_ref);
				axl_free (comp_name_lower);
			}
			    
			xml_rpc_support_sl_write (");\n\n");
			
		}while ((aux2 = axl_node_get_next (aux2)) != NULL);
	}

	/* nothing more */
	return;
}

/** 
 * @internal
 * 
 * Writes the service stub invocator (synchronous and asynchronous)
 * for the one represented by the xml node reference (\ref axlNode).
 *
 * The function writes the synchronous part for the function.
 *
 * @param comp_name The xml rpc component name.
 *
 * @param node The xml node reference that contains the hole xml
 * service.
 *
 * @param is_header Signal that the service is a C header rather than
 * a C header for a body.
 */
void xml_rpc_c_stub_write_service_sync (axlDoc * doc, char  * comp_name, axlNode * node, axl_bool  is_header)
{
	char    * service_name;
	char    * return_type;
	char    * comp_name_lower;

	axlNode * aux;

	/* get service name */
	aux          = axl_node_get_child_nth (node, 0);
	service_name = axl_node_get_content_trim (aux, NULL);
	
	/* get return type */
	aux          = axl_node_get_next (aux);
	return_type  = axl_node_get_content_trim (aux, NULL);

	/* get component name */
	comp_name_lower = xml_rpc_support_to_lower (comp_name);

	/* check if the service is inside a resource or next node is
	 * the params */
	aux          = axl_node_get_next (aux);
	if (NODE_CMP_NAME (aux, "resource")) {
		/* it is a resource declaration, manage it */
		
		/* get the reference to the params node */
		aux  = axl_node_get_next (aux);
	}

	/* write the initial service name */
	xml_rpc_support_write ("/* service: %s */\n", service_name);

	xml_rpc_c_stub_write_native_type (doc, return_type, axl_false);

	xml_rpc_support_sl_write (" %s_%s", comp_name_lower, service_name);
	

	/* write function type prefix */
	xml_rpc_support_write_function_type_prefix (aux);

	/* write synchronous invocation sign */
	xml_rpc_support_write ("_s (");

	/* write function parameters */
	xml_rpc_support_write_function_parameters (doc, aux);

	/* write header end */
	if (axl_node_have_childs (aux))
		xml_rpc_support_sl_write (", ");
	xml_rpc_support_write ("VortexChannel * channel, XmlRpcResponseStatus * status, int * fault_code, char ** fault_string)");

	if (is_header) 
		xml_rpc_support_write (";");
	xml_rpc_support_write ("\n");

	/* free resources */
	axl_free (comp_name_lower);

	return;

}

/** 
 * @internal
 *
 * Common implementation to check if a provided type name is an array
 * or an struct definition.
 *
 * n@param doc The xml document that describes the interface
 *
 * @param type_name The type name to check
 *
 * @param type "struct" or "array" to check the type name received.
 * 
 * @return axl_true if the provided type is a struct or an array according
 * to the value received at type.
 */
axl_bool  __xml_rpc_c_stub_type_is_common (axlDoc * doc, char  * type_name, char  * type)
{
	axlNode * node;
	axlNode * node_name;
	char    * name;

	/* write all struct definitions */
	node = axl_doc_get (doc, "/xml-rpc-interface/name");

	while ((node = axl_node_get_next (node)) != NULL) {

		/* check for the struct case */
		if (axl_cmp (axl_node_get_name (node), type)) {

			/* get the node name */
			node_name = axl_node_get_child_called (node, "name");
			name      = axl_node_get_content_trim (node_name, NULL);

			/* check the value */
			if (axl_cmp (name, type_name))
				return axl_true;
		} /* if */
	} /* while */
	
	return axl_false;
}

/** 
 * @internal
 *
 * Internal function which allows to check if the provided type alias
 * name is an struct.
 * 
 * @param doc The axlDoc where that represents the xml rpc interface.
 *
 * @param return_type The return type that is being checked.
 * 
 * @return 
 */
axl_bool  xml_rpc_c_stub_type_is_struct (axlDoc * doc, char  * type_name)
{
	return __xml_rpc_c_stub_type_is_common (doc, type_name, "struct");
}

/** 
 * @internal
 *
 * Internal function which allows to check if the provided type alias
 * name is an array.
 * 
 * @param doc The axlDoc where that represents the xml rpc interface.
 *
 * @param return_type The return type that is being checked.
 * 
 * @return 
 */
axl_bool  xml_rpc_c_stub_type_is_array (axlDoc * doc, char  * type_name)
{
	return __xml_rpc_c_stub_type_is_common (doc, type_name, "array");
}

/** 
 * @internal
 * 
 * Writes the service stub invocator (synchronous and asynchronous)
 * for the one represented by the xml node reference (\ref axlNode).
 *
 * The function writes the asynchronous part for the function.
 *
 * @param comp_name The xml rpc component name.
 *
 * @param node The xml node reference that contains the hole xml
 * service.
 *
 * @param is_header Signal that the service is a C header rather than
 * a C header for a body.
 */
void xml_rpc_c_stub_write_service (axlDoc  * doc,
				   char    * comp_name, 
				   axlNode * node, 
				   axl_bool  is_header)
{
	char    * service_name;
	char    * return_type;
	char    * comp_name_lower;

	axlNode * aux;

	/* get service name */
	aux          = axl_node_get_child_nth (node, 0);
	service_name = axl_node_get_content_trim (aux, NULL);
	
	/* get return type */
	aux          = axl_node_get_next (aux);
	return_type  = axl_node_get_content_trim (aux, NULL);

	/* get component name */
	comp_name_lower = xml_rpc_support_to_lower (comp_name);

	/* check if the service is inside a resource or next node is
	 * the params */
	aux          = axl_node_get_next (aux);
	if (NODE_CMP_NAME (aux, "resource")) {
		/* get the reference to the params node */
		aux  = axl_node_get_next (aux);
	}

	/* now the synchonouns invocation */
	/* write the initial service name */
	xml_rpc_support_write ("void %s_%s", comp_name_lower, service_name);

	/* write function type prefix */
	xml_rpc_support_write_function_type_prefix (aux);
	
	/* write synchronous invocation sign */
	xml_rpc_support_write (" (");

	/* write function parameters */
	xml_rpc_support_write_function_parameters (doc, aux);

	/* write header end */
	/* write header end */
	if (axl_node_have_childs (aux))
		xml_rpc_support_sl_write (", ");
	xml_rpc_support_write ("VortexChannel * channel, XmlRpcProcess");

	/* write the process according to the type */
	if (axl_cmp (return_type, "int"))
		xml_rpc_support_write ("Int");
	else if (axl_cmp (return_type, "bool"))
		xml_rpc_support_write ("Int");
	else if (axl_cmp (return_type, "string"))
		xml_rpc_support_write ("String");
	else if (axl_cmp (return_type, "base64"))
		xml_rpc_support_write ("String");
	else if (axl_cmp (return_type, "double"))
		xml_rpc_support_write ("Double");
	else {
		/* we are in the struct or array case: check which is
		 * the base type for the type definition received */
		if (xml_rpc_c_stub_type_is_struct (doc, return_type))
			xml_rpc_support_write ("Struct");
		else if (xml_rpc_c_stub_type_is_array (doc, return_type))
			xml_rpc_support_write ("Array");
		
	}
	
	xml_rpc_support_write_sl (" process)");

	if (is_header)
		xml_rpc_support_write_sl (";");
	else
		xml_rpc_support_write ("\n{");

	xml_rpc_support_write_sl ("\n\n");

	/* free resources */
	axl_free (comp_name_lower);

	return;
}

void xml_rpc_c_stub_write_struct_checkings (axlNode * _struct)
{
	axlDoc  * doc;
	axlNode * member;

	axlNode * name_node;
	char    * _name;

	axlNode * type_node;
	char    * type;

	doc = axl_node_get_doc (_struct);

	/* write the member count checking */
	xml_rpc_support_write ("/* check the number of items the provided struct */\n");
	xml_rpc_support_write ("v_return_val_if_fail (vortex_xml_rpc_struct_get_member_count (ref) == %d, NULL);\n",
			       axl_node_get_child_num (_struct) - 1);
	
	xml_rpc_support_write ("/* check member names */\n");
	xml_rpc_support_write ("v_return_val_if_fail (vortex_xml_rpc_struct_check_member_names (ref, %d", 
			       axl_node_get_child_num (_struct) - 1);
	
	/* write member names checking */
	member = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		xml_rpc_support_sl_write (", \"%s\"", _name);
		
	}while ((member = axl_node_get_next (member)) != NULL);

	xml_rpc_support_sl_write ("), NULL);\n");

	xml_rpc_support_write ("/* check member types */\n");
	xml_rpc_support_write ("v_return_val_if_fail (vortex_xml_rpc_struct_check_member_types (ref, %d", 
			       axl_node_get_child_num (_struct) - 1);

	/* write member types checking */
	member = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);
		
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			type = "struct";
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			type = "array";
		
		/* write the type checking line */
		xml_rpc_support_sl_write (", \"%s\"", type);
		
	}while ((member = axl_node_get_next (member)) != NULL);

	xml_rpc_support_sl_write ("), NULL);\n\n");

	return;
}

/** 
 * @internal
 *
 * Writes the struct header support file and its implementation. The
 * struct type have a separated file implementation which contains the
 * struct definition and some support functions (marshallers and
 * allocators).
 *
 * @param out_dir The component output dir.
 * 
 * @param comp_name The component name (the XML-RPC component).
 *
 * @param _struct The xml node that represents the XML-RPC structure.
 */
void xml_rpc_c_stub_write_struct_def (char  * out_dir,
				      char  * comp_name, 
				      axlNode * _struct)
{
	axlNode * name;
	char    * struct_upper;
	char    * struct_lower;
	char    * struct_name;

	char    * comp_name_upper;
	char    * comp_name_lower;

	axlNode * member;
	axl_bool  written;

	axlNode * type_node;
	char    * type;
	char    * type_lower;
	
	axlNode * name_node;
	char    * _name;

	axlDoc  * doc;

	/* get a reference to the document */
	doc  = axl_node_get_doc (_struct);

	/* get the lower and the upper representations */
	name = axl_node_get_child_nth (_struct, 0);

	/* get the struct name */
	struct_name     = axl_node_get_content_trim (name, NULL);
	
	struct_upper    = xml_rpc_support_to_upper (struct_name);
	struct_lower    = xml_rpc_support_to_lower (struct_name);

	/* get upper component name */
	comp_name_upper = xml_rpc_support_to_upper (comp_name);
	comp_name_lower = xml_rpc_support_to_lower (comp_name);

	/* open the file */
	xml_rpc_support_open_file ("%s/%s_struct_%s_xml_rpc.h",
				   out_dir, comp_name_lower, struct_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	xml_rpc_support_write ("#ifndef __XML_RPC_STRUCT_%s_H__\n", struct_upper);
	xml_rpc_support_write ("#define __XML_RPC_STRUCT_%s_H__\n\n", struct_upper);
	
	xml_rpc_support_write ("/* include base library */\n");
	xml_rpc_support_write ("#include <vortex.h>\n");
	xml_rpc_support_write ("/* include xml-rpc library */\n");
	xml_rpc_support_write ("#include <vortex_xml_rpc.h>\n");
	xml_rpc_support_write ("#include <%s_types.h>\n\n", comp_name_lower);

	xml_rpc_support_write ("/* %s type declaration */\n", struct_name);
	xml_rpc_support_write ("/* user definition declared at: %s_types.h */\n", comp_name_lower);

	xml_rpc_support_write ("struct __%s {\n", struct_name);

	xml_rpc_support_push_indent ();

	/* write each member */
	member = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);
		if (axl_cmp (type, "string"))
			xml_rpc_support_write ("char * %s;\n", _name);
		else if (axl_cmp (type, "bool"))
			xml_rpc_support_write ("axl_bool  %s;\n", _name);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("%s * %s;\n", type, _name);
		else if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("%s * %s;\n", type, _name);
		else
			xml_rpc_support_write ("%s %s;\n", type, _name);
		
	}while ((member = axl_node_get_next (member)) != NULL);

	xml_rpc_support_pop_indent ();
	xml_rpc_support_write ("};\n\n");

	/* write begin function declarations */
	xml_rpc_support_multiple_write ("/* support for c++ declarations */\n",
					"BEGIN_C_DECLS\n\n",
					NULL);

	/* write marshallers */
	xml_rpc_support_write ("/* (un)marshaller support functions  */\n");
	xml_rpc_support_write ("XmlRpcStruct * %s_%s_marshall (VortexCtx * _ctx_, %s * ref, axl_bool  dealloc);\n",
			       comp_name_lower, struct_lower, struct_name);
	xml_rpc_support_write ("%s * %s_%s_unmarshall (XmlRpcStruct * ref, axl_bool  dealloc);\n\n",
			       struct_name, comp_name_lower, struct_lower);
	
	xml_rpc_support_write ("/* memory (de)allocation functions */\n");
	xml_rpc_support_write ("%s * %s_%s_new (", struct_name, comp_name_lower, struct_lower);

	/* write all parameters */
	/* write each member */
	member  = axl_node_get_child_nth (_struct, 1);
	written = axl_false;
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);
		if (written)
			xml_rpc_support_sl_write (", ");
		written   = axl_true;

		if (axl_cmp (type, "string"))
			xml_rpc_support_sl_write ("const char * %s", _name);
		else if (axl_cmp (type, "bool"))
			xml_rpc_support_sl_write ("axl_bool  %s", _name);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("%s * %s", type, _name);
		else if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("%s * %s", type, _name);
		else
			xml_rpc_support_sl_write ("%s %s", type, _name);
		
	}while ((member = axl_node_get_next (member)) != NULL);

	/* end _new function */
	xml_rpc_support_sl_write (");\n\n");

	xml_rpc_support_write ("%s * %s_%s_copy (%s * ref);\n\n", struct_name, comp_name_lower, struct_lower, struct_name);

	xml_rpc_support_write ("void %s_%s_free (%s * ref);\n\n", comp_name_lower, struct_lower, struct_name);


	/* write function end declarations */
	xml_rpc_support_multiple_write ("END_C_DECLS\n\n",
					"#endif\n",
					NULL);

	/* close the file */
	xml_rpc_support_close_file ();

	/**
	 * Now create the body file implementation.
	 */
	
	/* open the file */
	xml_rpc_support_open_file ("%s/%s_struct_%s_xml_rpc.c",
				   out_dir, comp_name_lower, struct_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	xml_rpc_support_write ("#include <%s_types.h>\n\n", comp_name_lower);

	xml_rpc_support_write ("/* (un)marshaller support functions  */\n");
	xml_rpc_support_write ("XmlRpcStruct * %s_%s_marshall (VortexCtx * _ctx_, %s * ref, axl_bool  dealloc)\n{\n",
			       comp_name_lower, struct_lower, struct_name);

	/* push indent to write the marshall function  */
	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("XmlRpcStruct       * _result;\n",
					"XmlRpcStructMember * _member;\n\n",
					"/* check received reference */\n",
					"if (ref == NULL)\n",
					"\treturn NULL;\n",
					NULL);
	
	xml_rpc_support_write ("/* create the struct */\n");
	xml_rpc_support_write ("_result = vortex_xml_rpc_struct_new (%d);\n\n",
			       axl_node_get_child_num (_struct) - 1);

	
	/* write all parameters */
	/* write each member */
	member  = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);

		xml_rpc_support_write ("/* %s member */\n", _name);
		xml_rpc_support_write ("_member = vortex_xml_rpc_struct_member_new (\"%s\", method_value_new (_ctx_, ", _name);
		
		if (axl_cmp (type, "int"))
			xml_rpc_support_sl_write ("XML_RPC_INT_VALUE, INT_TO_PTR (ref->%s)));\n", _name);
		else if (axl_cmp (type, "bool"))
			xml_rpc_support_sl_write ("XML_RPC_BOOLEAN_VALUE, INT_TO_PTR (ref->%s)));\n", _name);
		else if (axl_cmp (type, "double"))
			xml_rpc_support_sl_write ("XML_RPC_DOUBLE_VALUE, &(ref->%s)));\n", _name);
		else if (axl_cmp (type, "string"))
			xml_rpc_support_sl_write ("XML_RPC_STRING_VALUE, ref->%s ? ref->%s : \"\"));\n", _name, _name);
		else if (axl_cmp (type, "base64"))
			xml_rpc_support_sl_write ("XML_RPC_BASE64_VALUE, ref->%s ? ref->%s : \"\"));\n", _name, _name);

		else {
			type_lower = xml_rpc_support_to_lower (type);
			if (xml_rpc_c_stub_type_is_array (doc, type))
				xml_rpc_support_sl_write ("XML_RPC_ARRAY_VALUE, %s_%s_marshall (_ctx_, ref->%s, axl_false)));\n", comp_name_lower, type_lower, _name);
			else if (xml_rpc_c_stub_type_is_struct (doc, type))
				xml_rpc_support_sl_write ("XML_RPC_STRUCT_VALUE, %s_%s_marshall (_ctx_, ref->%s, axl_false)));\n", comp_name_lower, type_lower, _name);
			axl_free (type_lower);
		}

		xml_rpc_support_write ("vortex_xml_rpc_struct_add_member (_result, _member);\n\n");

	}while ((member = axl_node_get_next (member)) != NULL);
	
	xml_rpc_support_multiple_write ("/* dealloc data source */\n",
					"if (dealloc)\n",
					NULL);

	xml_rpc_support_push_indent ();
	xml_rpc_support_write ("%s_%s_free (ref);\n\n", comp_name_lower, struct_lower);
	xml_rpc_support_pop_indent ();
	
	xml_rpc_support_multiple_write ("/* return result created */\n",
					"return _result;\n",
					NULL);
	/* pop indent to close the marshal function */
	xml_rpc_support_pop_indent ();
	

	xml_rpc_support_write ("}\n\n");

	/* write the unmarshall implementation */
	xml_rpc_support_write ("%s * %s_%s_unmarshall (XmlRpcStruct * ref, axl_bool  dealloc)\n{\n",
			       struct_name, comp_name_lower, struct_lower);

	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("%s * _result;\n\n", struct_name);

	xml_rpc_support_multiple_write ("/* check received reference */\n",
					"if (ref == NULL)\n",
					"\treturn NULL;\n\n",
					NULL);
	
	/* write all checkings */
	xml_rpc_c_stub_write_struct_checkings (_struct);

	xml_rpc_support_write ("_result = %s_%s_new (\n", comp_name_lower, struct_lower);
	
	/* push the indent for all parameters */
	xml_rpc_support_push_indent ();
	
	/* write all parameters */
	/* write each member */
	member  = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);

		if (axl_cmp (type, "int"))
			xml_rpc_support_write ("vortex_xml_rpc_struct_get_member_value_as_int (ref, \"%s\")", _name);
		else if (axl_cmp (type, "bool"))
			xml_rpc_support_write ("vortex_xml_rpc_struct_get_member_value_as_int (ref, \"%s\")", _name);
		else if (axl_cmp (type, "double"))
			xml_rpc_support_write ("vortex_xml_rpc_struct_get_member_value_as_double (ref, \"%s\")", _name);
		else if (axl_cmp (type, "string"))
			xml_rpc_support_write ("vortex_xml_rpc_struct_get_member_value_as_string (ref, \"%s\")", _name);
		else if (axl_cmp (type, "base64"))
			xml_rpc_support_write ("vortex_xml_rpc_struct_get_member_value_as_string (ref, \"%s\")", _name);
		else {
			type_lower = xml_rpc_support_to_lower (type);
			if (xml_rpc_c_stub_type_is_array (doc, type))
				xml_rpc_support_write ("%s_%s_unmarshall (vortex_xml_rpc_struct_get_member_value_as_array (ref, \"%s\"), axl_false)", 
						       comp_name_lower, type_lower, _name);
			else if (xml_rpc_c_stub_type_is_struct (doc, type))
				xml_rpc_support_write ("%s_%s_unmarshall (vortex_xml_rpc_struct_get_member_value_as_struct (ref, \"%s\"), axl_false)", 
						       comp_name_lower, type_lower, _name);
			axl_free (type_lower);
		}
		
		if (axl_node_get_next (member))
			xml_rpc_support_sl_write (",\n");
		else
			xml_rpc_support_sl_write (");\n\n");

	}while ((member = axl_node_get_next (member)) != NULL);
	
	xml_rpc_support_pop_indent ();

	xml_rpc_support_multiple_write ("/* dealloc data source */\n",
					"if (dealloc)\n",
					"\tvortex_xml_rpc_struct_free (ref);\n\n",
					"return _result;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	/* write the new function */
	xml_rpc_support_write ("/* memory (de)allocation functions */\n");
	xml_rpc_support_write ("%s * %s_%s_new (", struct_name, comp_name_lower, struct_lower);

	/* write all parameters */
	/* write each member */
	member  = axl_node_get_child_nth (_struct, 1);
	written = axl_false;
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);
		if (written)
			xml_rpc_support_sl_write (", ");
		written   = axl_true;

		if (axl_cmp (type, "string"))
			xml_rpc_support_sl_write ("const char * %s", _name);
		else if (axl_cmp (type, "bool"))
			xml_rpc_support_sl_write ("axl_bool  %s", _name);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("%s * %s", type, _name);
		else if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("%s * %s", type, _name);
		else
			xml_rpc_support_sl_write ("%s %s", type, _name);
		
	}while ((member = axl_node_get_next (member)) != NULL);

	/* end _new function */
	xml_rpc_support_sl_write (")\n{\n");
	
	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("%s * _result = axl_new (%s, 1);\n\n", struct_name, struct_name);
	
	member  = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);		

		if (axl_cmp (type, "int") || 
		    axl_cmp (type, "double") || 
		    axl_cmp (type, "bool") ||
		    xml_rpc_c_stub_type_is_array (doc, type) ||
		    xml_rpc_c_stub_type_is_struct (doc, type)) {
			xml_rpc_support_write ("_result->%s = %s;\n", _name, _name);
		} else if (axl_cmp (type, "string") ||
			   axl_cmp (type, "base64")) {
			xml_rpc_support_write ("_result->%s = axl_strdup (%s);\n", _name, _name);
		}

	}while ((member = axl_node_get_next (member)) != NULL);
	

	xml_rpc_support_write ("\n");

	xml_rpc_support_write ("return _result;\n");
	
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	/* write the copy function */
	xml_rpc_support_write ("%s * %s_%s_copy (%s * ref)\n{\n", struct_name, comp_name_lower, struct_lower, struct_name);
	
	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("%s * _result = NULL;\n\n", struct_name);

	xml_rpc_support_write ("if (ref == NULL)\n");
	xml_rpc_support_write ("\treturn NULL;\n\n");


	xml_rpc_support_write ("_result = axl_new (%s, 1);\n", struct_name);
	
	member  = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);		

		if (axl_cmp (type, "int") || 
		    axl_cmp (type, "double") || 
		    axl_cmp (type, "bool")) {
			xml_rpc_support_write ("_result->%s = ref->%s;\n", _name, _name);
		} else if (xml_rpc_c_stub_type_is_array (doc, type) ||
			   xml_rpc_c_stub_type_is_struct (doc, type)) {
			type_lower = xml_rpc_support_to_lower (type);
			xml_rpc_support_write ("_result->%s = %s_%s_copy (ref->%s);\n", 
					       _name, comp_name_lower, type_lower, _name);
			axl_free (type_lower);
			type_lower = NULL;
		} else if (axl_cmp (type, "string") ||
			   axl_cmp (type, "base64")) {
			xml_rpc_support_write ("_result->%s = axl_strdup (ref->%s);\n", _name, _name);
		}

	}while ((member = axl_node_get_next (member)) != NULL);
	

	xml_rpc_support_write ("\n");

	xml_rpc_support_write ("return _result;\n");

	xml_rpc_support_pop_indent ();
	xml_rpc_support_write ("}\n\n");
	

	/* write the free function */
	xml_rpc_support_write ("void %s_%s_free (%s * ref)\n{\n", comp_name_lower, struct_lower, struct_name);

	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("if (ref == NULL)\n");
	xml_rpc_support_write ("\treturn;\n");

	member  = axl_node_get_child_nth (_struct, 1);
	do {
		/* get the node name */
		name_node = axl_node_get_child_nth (member, 0);
		_name     = axl_node_get_content_trim (name_node, NULL);
		
		/* get the type node */
		type_node = axl_node_get_child_nth (member, 1);
		type      = axl_node_get_content_trim (type_node, NULL);		

		if (axl_cmp (type, "int") || 
		    axl_cmp (type, "double") || 
		    axl_cmp (type, "bool")) {
			/* nothing to do */
		}else if (axl_cmp (type, "string") ||
		    axl_cmp (type, "base64")) {
			xml_rpc_support_write ("if (ref->%s)\n", _name);
			xml_rpc_support_write ("\taxl_free (ref->%s);\n", _name);
		}else {
			type_lower = xml_rpc_support_to_lower (type);
			xml_rpc_support_write ("if (ref->%s)\n", _name);
			if (xml_rpc_c_stub_type_is_array (doc, type))
				xml_rpc_support_write ("\t%s_%s_free (ref->%s);\n", comp_name_lower, type_lower, _name);
			if (xml_rpc_c_stub_type_is_struct (doc, type))
				xml_rpc_support_write ("\t%s_%s_free (ref->%s);\n", comp_name_lower, type_lower, _name);
			axl_free (type_lower);
		}
		
	}while ((member = axl_node_get_next (member)) != NULL);
	

	/* mandatory deallocation function */
	xml_rpc_support_multiple_write ("if (ref != NULL)\n",
					"\taxl_free (ref);\n",
					"return;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");
	

	/* close the body implemenation */
	xml_rpc_support_close_file ();


	axl_free (struct_upper);
	axl_free (struct_lower);
	
	axl_free (comp_name_lower);
	axl_free (comp_name_upper);

	/* nothing more */
	return;
}

/** 
 * @brief Provided an XML-RPC type name, this function writes the
 * native correspondence.
 * 
 * @param doc The XML document that describes the interface.
 *
 * @param type The type name (XML-RPC type), int, bool, date,
 * double, string, base64, struct and array. For the array and the
 * struct cases, it is required to received the type name not the
 * class.
 *
 * @param same_line Writes the type into the same line or use the API
 * provided to produce tabular indentation.
 */
void xml_rpc_c_stub_write_native_type (axlDoc * doc, char  * type, axl_bool      same_line)
{
	char  * type_write = "";

	if (axl_cmp (type, "string") || axl_cmp (type, "base64"))
		type_write = "char *";
	else if (axl_cmp (type, "int"))
		type_write = "int";
	else if (axl_cmp (type, "bool"))
		type_write = "axl_bool";
	else if (axl_cmp (type, "double"))
		type_write = "double";
	else if (axl_cmp (type, "date"))
		type_write = "--NOT SUPPORTED--";
	else {
		if (xml_rpc_c_stub_type_is_array (doc, type) || xml_rpc_c_stub_type_is_struct (doc, type)) {
			if (same_line)
				xml_rpc_support_sl_write ("%s *", type);
			else 
				xml_rpc_support_write ("%s *", type);
			return;
		}
	}

	if (same_line)
		xml_rpc_support_sl_write (type_write);
	else 
		xml_rpc_support_write (type_write);
	return;

	return;
}


/** 
 * @internal
 *
 * Writes the header and the body definition for the array.
 * 
 * @param result The result directory, where the array module
 * definition will be placed.
 *
 * @param comp_name The XML-RPC component name.
 *
 * @param node The node that contains the array definition.
 */
void xml_rpc_c_stub_write_array_def (char  * out_dir, char  * comp_name, axlNode * array, axlDoc * doc)
{
	/* component name */
	char    * comp_name_upper;
	char    * comp_name_lower;

	/* array name variables */
	char    * name;
	char    * name_upper;
	char    * name_lower;
	axlNode * node_name;

	/* array type variables */
	char    * type;
	char    * type_lower;
	char    * type_upper;
	axlNode * node_type;

	/* array size variables */
	char    * size;
	axlNode * node_size;

	/* get the struct name */
	node_name       = axl_node_get_child_nth (array, 0);
	name            = axl_node_get_content_trim (node_name, NULL);

	name_upper      = xml_rpc_support_to_upper (name);
	name_lower      = xml_rpc_support_to_lower (name);

	/* get upper component name */
	comp_name_upper = xml_rpc_support_to_upper (comp_name);
	comp_name_lower = xml_rpc_support_to_lower (comp_name);

	/* get the type */
	node_type  = axl_node_get_child_nth (array, 1);
	type       = axl_node_get_content_trim (node_type, NULL);
	type_lower = xml_rpc_support_to_lower (type);
	type_upper = xml_rpc_support_to_upper (type);
	
	/* get the size */
	node_size = axl_node_get_child_nth (array, 2);
	size      = axl_node_get_content_trim (node_size, NULL);

	/* open the header file */
	xml_rpc_support_open_file ("%s/%s_array_%s_xml_rpc.h",
				   out_dir, comp_name_lower, name_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	/* write typedef */
	xml_rpc_support_write ("#ifndef __XML_RPC_ARRAY_%s_H__\n",   name_upper);
	xml_rpc_support_write ("#define __XML_RPC_ARRAY_%s_H__\n\n", name_upper);
	
	xml_rpc_support_write ("/* include base library */\n");
	xml_rpc_support_write ("#include <vortex.h>\n");
	xml_rpc_support_write ("/* include xml-rpc library */\n");
	xml_rpc_support_write ("#include <vortex_xml_rpc.h>\n");
	xml_rpc_support_write ("#include <%s_types.h>\n\n", comp_name_lower);

	xml_rpc_support_multiple_write ("/* support for c++ declarations */\n",
					"BEGIN_C_DECLS\n\n",
					"/* (un)marshaller support functions  */\n",
					NULL);

	/* write marshallers */
	xml_rpc_support_write ("XmlRpcArray    * %s_%s_marshall   (VortexCtx * _ctx_, %s * ref, axl_bool  dealloc);\n",
			       comp_name_lower, name_lower, name);
	xml_rpc_support_write ("%s * %s_%s_unmarshall (XmlRpcArray * ref, axl_bool  dealloc);\n\n",
			       name, comp_name_lower, name_lower);

	/* write memory allocators */
	xml_rpc_support_write ("/* memory (de)allocation functions */\n");
	xml_rpc_support_write ("%s * %s_%s_new  (int count);\n", name, comp_name_lower, name_lower);
	write ("%s * %s_%s_copy (%s * ref);\n", name, comp_name_lower, name_lower, name);
	xml_rpc_support_write ("void %s_%s_free (%s * ref);\n\n", comp_name_lower, name_lower, name);

	/* write manipulation functions */
	xml_rpc_support_write ("/* manipulation functions */\n");
	xml_rpc_c_stub_write_native_type (doc, type, axl_false);
	xml_rpc_support_sl_write (" %s_%s_get (%s * ref, int index);\n",
				  comp_name_lower, name_lower, name);

	/* write the set functions */
	xml_rpc_support_write ("void %s_%s_set (%s * ref, int index, ",
			       comp_name_lower, name_lower, name);
	xml_rpc_c_stub_write_native_type (doc, type, axl_true);
	xml_rpc_support_write (" value);\n");

	/* do not provide add method for bool, double and int since is
	 * not possible to check which is the next free position
	 * available */
	if (axl_cmp (type, "int") || axl_cmp (type, "double") || axl_cmp (type, "bool")) {
		write ("/* %s_%s_add not available to due to holding type %s */\n",
		       comp_name_lower, name_lower, type);
	} else {
		write ("void %s_%s_add (%s * ref, ", comp_name_lower, name_lower, name);
	
		xml_rpc_c_stub_write_native_type (doc, type, axl_true);
		xml_rpc_support_write (" value);\n\n");
	}

	/* write the count function */
	xml_rpc_support_write ("int %s_%s_count (%s * ref);\n\n",
			       comp_name_lower, name_lower, name);
	
	/* write end c decls */
	xml_rpc_support_multiple_write ("END_C_DECLS\n\n",
					"#endif\n",
					NULL);

	/* close the header finition */
	xml_rpc_support_close_file ();

	/* now create the body implementation */
	xml_rpc_support_open_file ("%s/%s_array_%s_xml_rpc.c",
				   out_dir, comp_name_lower, name_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	/* write initial include */
	xml_rpc_support_write ("#include <%s_types.h>\n\n", comp_name_lower);
	
	xml_rpc_support_write ("/* opaque definition */\n");
	xml_rpc_support_write ("struct __%s {\n", name);
	
	/* push indent */
	xml_rpc_support_push_indent ();
	
	/* according to the type, write the internal definition to
	 * hold its values */
	if (axl_cmp (type, "int") || axl_cmp (type, "double"))
		xml_rpc_support_write ("%s * array;\n", type);
	else if (axl_cmp (type, "bool"))
		xml_rpc_support_write ("axl_bool  * array;\n");
	else if (axl_cmp (type, "string")) 
		xml_rpc_support_write ("char ** array;\n");
	else 
		xml_rpc_support_write ("%s ** array;\n", type);
	xml_rpc_support_write ("int count;\n");

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("};\n\n");

	/* write marshallers */
	xml_rpc_support_write ("XmlRpcArray    * %s_%s_marshall   (VortexCtx * _ctx_, %s * ref, axl_bool  dealloc)\n{\n",
			       comp_name_lower, name_lower, name);

	/* push indent */
	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("/* array and method value */\n",
					"XmlRpcArray * _result;\n",
					"XmlRpcMethodValue * _array_value;\n\n",
					"/* iterator */\n",
					"int  iterator = 0;\n\n",
					NULL);
	
	/* writ the variable that will contain the marshalled value */
	xml_rpc_support_write ("/* access variables */\n");
	if (axl_cmp (type, "int") || axl_cmp (type, "double"))
		xml_rpc_support_write ("%s _value;\n", type);
	else if (axl_cmp (type, "bool"))
		xml_rpc_support_write ("axl_bool  _value;\n", type);
	else if (axl_cmp (type, "string")) 
		xml_rpc_support_write ("char * _value;\n");
	else 
		xml_rpc_support_write ("%s * _value;\n", type);

	if (! (axl_cmp (type, "int") || axl_cmp (type, "bool") || axl_cmp (type, "double"))) {
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("XmlRpcStruct * _struct;\n\n");
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("XmlRpcArray * _array;\n\n");
	}

	xml_rpc_support_multiple_write ("if (ref == NULL)\n",
					"\treturn NULL;\n\n",
					"/* create the XmlRpcArray */\n",
					"_result = vortex_xml_rpc_array_new (ref->count);\n\n",
					"while (iterator < ref->count) {\n",
					NULL);

	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("/* get the array value */\n",
					"_value = ref->array[iterator];\n\n",
					NULL);

	if (! (axl_cmp (type, "int") || axl_cmp (type, "bool") || axl_cmp (type, "double"))) {
		xml_rpc_support_write ("/* translate the value */\n");
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("_struct = %s_%s_marshall (_ctx_, _value, axl_false);\n",
					       comp_name_lower, type_lower);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("_array = %s_%s_marshall (_ctx_, _value, axl_false);\n");
	}

	xml_rpc_support_write ("_array_value = method_value_new (_ctx_, XML_RPC_");
	if (axl_cmp (type, "int") || axl_cmp (type, "double") || 
	    axl_cmp (type, "string") || axl_cmp (type, "base64"))
		xml_rpc_support_sl_write ("%s", type_upper);
	else if (axl_cmp (type, "bool")) 
		xml_rpc_support_sl_write ("BOOLEAN");
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_sl_write ("STRUCT");
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_sl_write ("ARRAY");
	}
	xml_rpc_support_sl_write ("_VALUE, ");
			

	if (axl_cmp (type, "int") || axl_cmp (type, "bool"))
		xml_rpc_support_sl_write ("INT_TO_PTR (_value)");
	else if (axl_cmp (type, "double"))
		xml_rpc_support_sl_write ("&_value");
	else if (axl_cmp (type, "string"))
		xml_rpc_support_sl_write ("_value");
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_sl_write ("_struct");
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_sl_write ("_array");
	}
	xml_rpc_support_sl_write (");\n\n");

	xml_rpc_support_multiple_write ("/* add the value to the array */\n",
					"vortex_xml_rpc_array_add (_result, _array_value);\n\n",
					"/* update the iterator */\n",
					"iterator++;\n",
					NULL);
	
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	xml_rpc_support_write ("/* dealloc the %s reference */\n", name);
	xml_rpc_support_write ("if (dealloc)\n");

	xml_rpc_support_push_indent ();
	xml_rpc_support_write ("%s_%s_free (ref);\n\n", comp_name_lower, name_lower);
	xml_rpc_support_pop_indent ();
	
	xml_rpc_support_multiple_write ("/* return the array created */\n",
					"return _result;\n",
					NULL);
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");	

	xml_rpc_support_write ("%s * %s_%s_unmarshall (XmlRpcArray * ref, axl_bool  dealloc)\n{\n",
			       name, comp_name_lower, name_lower);

	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("%s * _result;\n", name);
	if (axl_cmp (type, "int") || axl_cmp (type, "double"))
		xml_rpc_support_write ("%s _value;\n", type);
	else if (axl_cmp (type, "bool"))
		xml_rpc_support_write ("axl_bool  _value;\n", type);
	else if (axl_cmp (type, "string") || (axl_cmp (type, "base64")))
		xml_rpc_support_write ("char  * _value;\n");
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_write ("%s * _value;\n", type);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_write ("%s * _value;\n", type);
	}
	
	
	if (xml_rpc_c_stub_type_is_struct (doc, type))
		xml_rpc_support_write ("XmlRpcStruct * _rpc_value;\n");
	else if (xml_rpc_c_stub_type_is_array (doc, type))
		xml_rpc_support_write ("XmlRpcArray * _rpc_value;\n");


	xml_rpc_support_multiple_write ("XmlRpcMethodValue * _array_value;\n",
					"int  iterator = 0;\n\n",
					"if (ref == NULL)\n",
					"\treturn NULL;\n\n",
					"/* create the array */\n",
					NULL);

	xml_rpc_support_write ("_result = %s_%s_new (vortex_xml_rpc_array_count (ref));\n\n",
			       comp_name_lower, name_lower);

	xml_rpc_support_write ("while (iterator < _result->count) {\n");
	
	xml_rpc_support_push_indent ();
	
	xml_rpc_support_multiple_write ("/* get the method value inside */\n",
					"_array_value = vortex_xml_rpc_array_get (ref, iterator);\n\n",
					NULL);
	/* write the translation code */
	xml_rpc_support_write ("/* translate the value */\n");
	if (axl_cmp (type, "int") || axl_cmp (type, "double"))
		xml_rpc_support_write ("_value = method_value_get_as_int (_array_value);\n");
	else if (axl_cmp (type, "bool"))
		xml_rpc_support_write ("_value = method_value_get_as_int (_array_value);\n");
	else if (axl_cmp (type, "string") || (axl_cmp (type, "base64")))
		xml_rpc_support_write ("_value = method_value_get_as_string (_array_value);\n");
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, type)) {
			xml_rpc_support_write ("_rpc_value = method_value_get_as_struct (_array_value);\n");
			xml_rpc_support_write ("_value     = %s_%s_unmarshall (_rpc_value, axl_false);\n", 
					       comp_name_lower, type_lower);
		} else if (xml_rpc_c_stub_type_is_array (doc, type)) {
			xml_rpc_support_write ("_rpc_value = method_value_get_as_array (_array_value);\n");
			xml_rpc_support_write ("_value     = %s_%s_unmarshall (_rpc_value, axl_false);\n", 
					       comp_name_lower, type_lower);
		}
	}	

	xml_rpc_support_multiple_write ("\n",
					"/* set the value */\n",
					"_result->array[iterator] = _value;\n\n",
					"/* update the iterator */\n",
					"iterator++;\n",
					NULL);
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n");

	xml_rpc_support_multiple_write ("/* deallocate memory used by the xml-rpc array */\n",
					"if (dealloc)\n",
					"\tvortex_xml_rpc_array_free (ref);\n\n",
					"return _result;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	xml_rpc_support_write ("%s * %s_%s_new  (int count)\n{\n", name, comp_name_lower, name_lower);
	
	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("%s * array;\n", name);

	xml_rpc_support_write ("/* create the reference */\n");
	xml_rpc_support_write ("array        = axl_new (%s, 1);\n", name);
	xml_rpc_support_write ("array->count = count;\n");
	
	xml_rpc_support_write ("array->array = axl_new (");
	if (axl_cmp (type, "int"))
		xml_rpc_support_sl_write ("int");
	if (axl_cmp (type, "double"))
		xml_rpc_support_sl_write ("double");
	else if (axl_cmp (type, "bool"))
		xml_rpc_support_sl_write ("axl_bool");
	else if (axl_cmp (type, "string") || (axl_cmp (type, "base64")))
		xml_rpc_support_sl_write ("char  *");
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, type))
			xml_rpc_support_sl_write ("%s *", type);
		else if (xml_rpc_c_stub_type_is_array (doc, type))
			xml_rpc_support_sl_write ("%s *", type);
	}	
	xml_rpc_support_sl_write (", count);\n\n");

	xml_rpc_support_multiple_write ("/* return the result */\n",
					"return array;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	write ("%s * %s_%s_copy (%s * ref)\n{\n", name, comp_name_lower, name_lower, name);

	push_indent ();

	write ("%s * array;\n", name);
	write ("int         iterator = 0;\n\n");

	write ("if (ref == NULL)\n");
	write ("\treturn NULL;\n\n");

	write ("/* create the reference */\n");
	write ("array        = axl_new (%s, 1);\n", name);
	write ("array->count = ref->count;\n");
	write ("if (array->count == 0)\n");
	write ("\treturn array;\n\n");

	write ("/* allocate enough space */\n");
	if (axl_cmp (type, "string")) 
		write ("array->array = axl_new (char *, array->count);\n");
	else if (axl_cmp (type, "bool")) 
		write ("array->array = axl_new (int, array->count);\n");
	else if (axl_cmp (type, "int")) 
		write ("array->array = axl_new (int, array->count);\n");
	else if (axl_cmp (type, "double")) 
		write ("array->array = axl_new (double, array->count);\n");
	else
		write ("array->array = axl_new (%s *, array->count);\n", type);
	write ("while (iterator < ref->count) {\n\n");

	push_indent ();

	write ("/* copy position */\n");
	if (axl_cmp (type, "string") || axl_cmp (type, "base64")) {
		write ("array->array[iterator] = axl_strdup (ref->array[iterator]);\n\n");
	} else if (xml_rpc_c_stub_type_is_array (doc, type) || xml_rpc_c_stub_type_is_struct (doc, type)) {
		write ("array->array[iterator] = %s_%s_copy (ref->array[iterator]);\n\n", comp_name_lower, type_lower);
	} else {
		write ("array->array[iterator] = ref->array[iterator];\n\n");
	}

	write ("/* update the iterator */\n");
	write ("iterator++;\n");
	
	pop_indent ();

	write ("}\n\n");

	write ("/* return array created */\n");
	write ("return array;\n");

	pop_indent ();

	write ("}\n\n");

	/* create the deallocator function */
	xml_rpc_support_write ("void %s_%s_free (%s * ref)\n{\n",
			       comp_name_lower, name_lower, name);

	/* write the function content */
	xml_rpc_support_push_indent ();

	if (axl_cmp (type, "string") || axl_cmp (type, "base64") || 
	    xml_rpc_c_stub_type_is_array (doc, type) || xml_rpc_c_stub_type_is_struct (doc, type)) {
		xml_rpc_support_write ("int iterator = 0;\n\n");
	}

	xml_rpc_support_multiple_write ("if (ref == NULL)\n",
					"\treturn;\n\n",
					NULL);

	if (axl_cmp (type, "string") || axl_cmp (type, "base64") || 
	    xml_rpc_c_stub_type_is_array (doc, type) || xml_rpc_c_stub_type_is_struct (doc, type)) {
		
		xml_rpc_support_write ("while (iterator < ref->count) {\n");

		/* write the while content */
		xml_rpc_support_push_indent ();

		xml_rpc_support_write ("/* release the content */\n");
		if (axl_cmp (type, "string") || axl_cmp (type, "base64"))
			xml_rpc_support_write ("axl_free (ref->array[iterator]);\n\n");
		else {
			/* array case */
			if (xml_rpc_c_stub_type_is_array (doc, type))
				xml_rpc_support_write ("%s_%s_free (ref->array[iterator]);\n\n",
						       comp_name_lower, type_lower);

			/* struct case */
			if (xml_rpc_c_stub_type_is_struct (doc, type))
				xml_rpc_support_write ("%s_%s_free (ref->array[iterator]);\n\n",
						       comp_name_lower, type_lower);
		}

		xml_rpc_support_multiple_write ("/* update the iterator */\n",
						"iterator++;\n",
						NULL);
		/* close while content */
		xml_rpc_support_pop_indent ();
		/* write the closing brace */
		xml_rpc_support_write ("}\n\n");
	}

	/* write the function last sentences */
	xml_rpc_support_multiple_write ("/* release the array reference itself */\n",
					"axl_free (ref->array);\n",
					"axl_free (ref);\n\n",
					"return;\n",
					NULL);

	
	xml_rpc_support_pop_indent ();

	/* write the closing brace */
	xml_rpc_support_write ("}\n\n");

	
	/* write the get function */
	xml_rpc_c_stub_write_native_type (doc, type, axl_false);

	/* write the function definition */
	xml_rpc_support_sl_write (" %s_%s_get (%s * ref, int index)\n{\n",
				  comp_name_lower, name_lower, name);

	/* write the get content function */
	xml_rpc_support_push_indent ();
	
	/* minimal common check */
	if (axl_cmp (type, "string") || axl_cmp (type, "base64") || 
	    xml_rpc_c_stub_type_is_array (doc, type) || xml_rpc_c_stub_type_is_struct (doc, type)) {
		write ("/* check received reference */\n");
		write ("v_return_val_if_fail (ref, NULL);\n\n");

		/* string, base64, array and struct */
		xml_rpc_support_multiple_write ("/* check index access */\n",
						"v_return_val_if_fail (index >= 0 &&  index < ref->count,  NULL);\n\n",
						"/* return the content */\n",
						"return ref->array[index];\n",
						NULL);
	} else {
		write ("/* check received reference */\n");
		write ("v_return_val_if_fail (ref, 0);\n\n");

		/* int, decimal and bool case */
		xml_rpc_support_multiple_write ("/* check index access */\n",
						"v_return_val_if_fail (index >= 0 &&  index < ref->count,  0);\n\n",
						"/* return the content */\n",
						"return ref->array[index];\n",
						NULL);
	}
	xml_rpc_support_pop_indent ();

	/* write the closing brace */
	xml_rpc_support_write ("}\n\n");

	
	/* write the set function */
	xml_rpc_support_write ("void %s_%s_set (%s * ref, int index, ",
			       comp_name_lower, name_lower, name);
	xml_rpc_c_stub_write_native_type (doc, type, axl_true);
	xml_rpc_support_write (" value)\n{\n");
	
	/* write the set content function */
	xml_rpc_support_push_indent ();

	/* minimal common check */
	write ("v_return_if_fail (ref);\n");
        xml_rpc_support_multiple_write ("/* check index access */\n",
					"v_return_if_fail (index >= 0 &&  index < ref->count);\n\n",
					"/* set the value */\n",
					"ref->array [index] = value;\n\n",
					"return;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	/* write the closing brace */
	xml_rpc_support_write ("}\n\n");

	/* write the add function */
	if (axl_cmp (type, "int") || axl_cmp (type, "double") || axl_cmp (type, "bool")) {
		write ("/* %s_%s_add not available to due to holding type %s */\n",
		       comp_name_lower, name_lower, type);
	} else {
		write ("void %s_%s_add (%s * ref, ", comp_name_lower, name_lower, name);
		xml_rpc_c_stub_write_native_type (doc, type, axl_true);
		xml_rpc_support_write (" value)\n{\n");
		
		/* write the set content function */
		push_indent ();
		
		write ("int iterator = 0;\n\n");
		
		write ("/* check index access */\n");
		write ("v_return_if_fail (ref && value);\n\n");
		
		write ("/* find the next free bucket */\n");
		write ("while (iterator < ref->count) {\n\n");
		
		push_indent ();
		
		write ("/* check free bucket */\n");
		write ("if (ref->array[iterator] == NULL) {\n");
		push_indent ();
		
		write ("/* found free bucket, set the data and return */\n");
		write ("ref->array[iterator] = value;\n");
		write ("return;\n");
	
		pop_indent ();
	
		write ("} /* end if */\n\n");

		write ("/* next position */\n");
		write ("iterator++;\n\n");

		pop_indent ();

		write ("} /* end while */\n\n");
		
		write ("return;\n");
	
		pop_indent ();
		
		write ("}\n\n");
	} /* end if */
	
	/* write the count function */
	xml_rpc_support_write ("int %s_%s_count (%s * ref)\n{\n",
			       comp_name_lower, name_lower, name);

	/* write the set content function */
	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("/* perform some checks */\n", 
					"v_return_val_if_fail (ref, -1);\n\n",
					"/* return the count */\n",
					"return ref->count;\n",
					NULL);

	xml_rpc_support_pop_indent ();

	/* write the closing brace */
	xml_rpc_support_write ("}\n\n");
	
	
	
	xml_rpc_support_close_file ();

	/* release memory */
	axl_free (name_upper);
	axl_free (name_lower);
	
	axl_free (comp_name_lower);
	axl_free (comp_name_upper);

	axl_free (type_lower);

	/* nothing more to do */
	return;
}


/** 
 * @internal
 * 
 * Writes the type header (that includes struct definitions, at this
 * moment).
 * 
 * @param result The directory result.
 *
 * @param comp_name The component name (the XML-RPC component name).
 *
 * @param node The xml node that is pointing to the xml-rpc-interface
 * name.
 */
void xml_rpc_c_stub_write_type_header (char  * result, char  * comp_name, axlDoc * doc)
{
	axlNode * node;

	/* component name */
	char    * comp_name_lower;
	char    * comp_name_upper;

	/* name content */
	char    * type_name;
	char    * type_name_lower;
	axlNode * name;

	/* type content */
	char    * type;
	axlNode * type_node;

	/* size content */
	char    * size;
	axlNode * size_node;

	/* get the lower name for the component */
	comp_name_lower = xml_rpc_support_to_lower (comp_name);
	comp_name_upper = xml_rpc_support_to_upper (comp_name);

	/* open the file */
	xml_rpc_support_open_file ("%s/%s_types.h", result, comp_name_lower);

	/* write the header file */
	xml_rpc_source_write_header (comp_name_lower);

	xml_rpc_support_write ("#ifndef __%s_XML_RPC_TYPES_H__\n", comp_name_upper);
	xml_rpc_support_write ("#define __%s_XML_RPC_TYPES_H__\n\n", comp_name_upper);

	/* write the type definition file */
	node = axl_doc_get (doc, "/xml-rpc-interface/name");
	
	/* write type definitions */
	while ((node = axl_node_get_next (node)) != NULL) {
		/* check if we have struct definitions to write them
		 * to the type file */
		if (axl_cmp (axl_node_get_name (node), "struct")) {
			
			/* get the node name */
			name        = axl_node_get_child_nth (node, 0);

			/* get the struct name */
			type_name   = axl_node_get_content_trim (name, NULL);

			/* write the declaration */
			xml_rpc_support_write ("/* %s type declaration */\n", type_name);
			xml_rpc_support_write ("typedef struct __%s %s;\n\n", type_name, type_name);
		}

		if (axl_cmp (axl_node_get_name (node), "array")) {
			/* get the array name */
			name      = axl_node_get_child_nth (node, 0);
			type_name = axl_node_get_content_trim (name, NULL);

			/* get the array type */
			type_node   = axl_node_get_child_nth (node, 1);
			type        = axl_node_get_content_trim (type_node, NULL);

			/* get the array size */
			size_node   = axl_node_get_child_nth (node, 2);
			size        = axl_node_get_content_trim (size_node, NULL);

			/* write the declaration */
			xml_rpc_support_write ("/* %s type declaration */\n", type_name);
			xml_rpc_support_write ("typedef struct __%s %s;\n\n", type_name, type_name);
			
		}
	}

	/* write the type definition file */
	node = axl_doc_get (doc, "/xml-rpc-interface/name");

	/* now write all include headers */
	while ((node = axl_node_get_next (node)) != NULL) {
		/* check if we have struct definitions to write them
		 * to the type file */
		if (axl_cmp (axl_node_get_name (node), "struct")) {
			
			/* get the node name */
			name        = axl_node_get_child_nth (node, 0);

			/* get the struct name */
			type_name       = axl_node_get_content_trim (name, NULL);
			type_name_lower = xml_rpc_support_to_lower (type_name);

			/* write the declaration */
			xml_rpc_support_write ("/* %s type interface */\n", type_name);
			xml_rpc_support_write ("#include <%s_struct_%s_xml_rpc.h>\n\n", 
					       comp_name_lower, type_name_lower);
			axl_free (type_name_lower);
		}

		
		if (axl_cmp (axl_node_get_name (node), "array")) {
			/* get the array name */
			name            = axl_node_get_child_nth (node, 0);
			type_name       = axl_node_get_content_trim (name, NULL);
			type_name_lower = xml_rpc_support_to_lower (type_name);

			/* get the array type */
			type_node   = axl_node_get_child_nth (node, 1);
			type        = axl_node_get_content_trim (type_node, NULL);

			/* get the array size */
			size_node   = axl_node_get_child_nth (node, 2);
			size        = axl_node_get_content_trim (size_node, NULL);

			/* write the declaration */
			xml_rpc_support_write ("/* %s type interface */\n", type_name);
			xml_rpc_support_write ("#include <%s_array_%s_xml_rpc.h>\n\n", 
					       comp_name_lower, type_name_lower);
			/* type name lower */
			axl_free (type_name_lower);
		}
	}


	/* nothing more to do */
	axl_free (comp_name_upper);
	axl_free (comp_name_lower);


	xml_rpc_support_write ("\n#endif\n");

	/* close the file */
	xml_rpc_support_close_file ();
	
	return;
}

/** 
 * @internal
 *
 * Writes all struct and array support modules to be usable from the
 * application level.
 * 
 * @param doc 
 */
void xml_rpc_c_stub_write_all_struct_and_array_defs (axlDoc * doc, char  * comp_name,
						     char  * out_dir)
{
	axlNode * node;

	node = axl_doc_get (doc, "/xml-rpc-interface/name");

	while ((node = axl_node_get_next (node)) != NULL) {
		/* check for the struct case */
		if (axl_cmp (axl_node_get_name (node), "struct")) {

			/* write the struct module */
			xml_rpc_c_stub_write_struct_def (out_dir, comp_name, node);
		}

		/* check for the array case */
		if (axl_cmp (axl_node_get_name (node), "array")) {
			
			/* write the array module */
			xml_rpc_c_stub_write_array_def (out_dir, comp_name, node, doc);
		}

	} /* while */
	
	return;
}

/** 
 * @internal
 *
 * Writes the XM-RPC header file.
 *
 * @param doc The XML-RPC document, representing the interface.
 * 
 * @param result The full path where it is located the client stub
 * generated.
 *
 * @param comp_name The XML-RPC component name.
 */
void xml_rpc_c_stub_create_header_file (axlDoc * doc, char  * result, char  * comp_name)
{
	axlNode * node;
	char    * comp_name_upper;
	char    * comp_name_lower;

	/* get component names */
	comp_name_upper = xml_rpc_support_to_upper (comp_name);
	comp_name_lower = xml_rpc_support_to_lower (comp_name);

	/* open the header stub */
	xml_rpc_support_open_file ("%s/%s_xml_rpc.h", result, comp_name_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	/* write C header and declarations */
	xml_rpc_support_write ("#ifndef __XML_RPC_%s_H__\n", comp_name_upper);
	xml_rpc_support_write ("#define __XML_RPC_%s_H__\n\n", comp_name_upper);

	/* write C headers includes */
	xml_rpc_support_write ("#include <%s_types.h>\n", comp_name_lower);

	xml_rpc_support_multiple_write ("/* include base library */\n",
					"#include <vortex.h>\n",
					"/* include xml-rpc library */\n",
					"#include <vortex_xml_rpc.h>\n\n",
					"/* support for c++ declarations */\n",
					"BEGIN_C_DECLS\n\n", NULL);

	/* free upper and lower copies */
	axl_free (comp_name_upper);
	axl_free (comp_name_lower);
	

	/* open the xml rpc interface, get the first node, inside the
	 * interface: <name> */
	node = axl_doc_get (doc, "/xml-rpc-interface/name");
	
	
	/* foreach top level node inside the xml-rpc interface */
	while ((node = axl_node_get_next (node)) != NULL) {

		/* check for the service case */
		if (axl_cmp (axl_node_get_name (node), "service")) {
			xml_rpc_c_stub_write_service_sync (doc, comp_name, node, axl_true);
			
			xml_rpc_c_stub_write_service (doc, comp_name, node, axl_true);
		}
	} /* while */

	/* write multiple lines */
	xml_rpc_support_multiple_write ("\nEND_C_DECLS\n\n",
					"#endif\n",
					NULL);

	/* close the file */
	xml_rpc_support_close_file ();

	/* write all struct and array definitions */
	xml_rpc_c_stub_write_all_struct_and_array_defs (doc, comp_name, result);

	/* write the type header */
	xml_rpc_c_stub_write_type_header (result, comp_name, doc);

	/* header created */
	return;
}

char  * xml_rpc_c_stub_write_service_body_sync_unmarshaller (axlDoc * doc, char  * return_type)
{
	if (axl_cmp (return_type, "int"))
		return "vortex_xml_rpc_unmarshall_int_sync";
	else if (axl_cmp (return_type, "bool"))
		return "vortex_xml_rpc_unmarshall_int_sync";
	else if (axl_cmp (return_type, "string"))
		return "vortex_xml_rpc_unmarshall_string_sync";
	else if (axl_cmp (return_type, "base64"))
		return "vortex_xml_rpc_unmarshall_string_sync";
	else if (axl_cmp (return_type, "double"))
		return "vortex_xml_rpc_unmarshall_double_sync";
	else if (axl_cmp (return_type, "struct"))
		return "vortex_xml_rpc_unmarshall_struct_sync";
	else if (axl_cmp (return_type, "array"))
		return "vortex_xml_rpc_unmarshall_array_sync";
	else {
		if (xml_rpc_c_stub_type_is_struct (doc, return_type))
			return "vortex_xml_rpc_unmarshall_struct_sync";
		if (xml_rpc_c_stub_type_is_array (doc, return_type))
			return "vortex_xml_rpc_unmarshall_array_sync";
	}

	return "--NOT-DEFINED--";
}

char  * xml_rpc_c_stub_write_service_body_async_unmarshaller (axlDoc * doc, char  * return_type)
{
	if (axl_cmp (return_type, "int"))
		return "vortex_xml_rpc_unmarshall_int";
	else if (axl_cmp (return_type, "bool"))
		return "vortex_xml_rpc_unmarshall_int";
	else if (axl_cmp (return_type, "string"))
		return "vortex_xml_rpc_unmarshall_string";
	else if (axl_cmp (return_type, "base64"))
		return "vortex_xml_rpc_unmarshall_string";
	else if (axl_cmp (return_type, "double"))
		return "vortex_xml_rpc_unmarshall_double";
	else  {
		if (xml_rpc_c_stub_type_is_struct (doc, return_type))
			return "vortex_xml_rpc_unmarshall_struct";
		if (xml_rpc_c_stub_type_is_array (doc, return_type))
			return "vortex_xml_rpc_unmarshall_array";
	}
	
	return "--NOT-DEFINED--";
}



/** 
 * @internal
 * 
 * Writes the service body for the stub invocator (synchronous and
 * asynchronous) for the one represented by the xml node reference
 * (\ref axlNode).
 *
 * @param comp_name The xml rpc component name.
 *
 * @param node The xml node reference that contains the hole xml
 * service.
 */
void xml_rpc_c_stub_write_service_body (axlDoc * doc, char  * comp_name, axlNode * node)
{
	char    * service_name;
	
	/* return type */
	char    * return_type;
	char    * return_type_lower;

	/* component name */
	char    * comp_name_lower;

	axlNode * aux;

	/* alternative method name support */
	char    * method_name;
	axlNode * aux2;

	/* get service name */
	aux          = axl_node_get_child_called (node, "name");
	service_name = axl_node_get_content_trim (aux, NULL);
	
	/* get return type */
	aux               = axl_node_get_child_called (node, "returns");
	return_type       = axl_node_get_content_trim (aux, NULL);
	return_type_lower = xml_rpc_support_to_lower (return_type);

	/* get lower version */
	comp_name_lower   = xml_rpc_support_to_lower (comp_name);

	/* check if the service is inside a resource or next node is
	 * the params */
	aux          = axl_node_get_child_called (node, "params");
	
	/* from here, aux points to <params> node (which is always
	 * defined) */

	/* write the function that creates the method invocator */
	xml_rpc_support_write ("XmlRpcMethodCall * __common_%s", service_name);
	
	/* write function type prefix */
	xml_rpc_support_write_function_type_prefix (aux);

	/* write synchronous invocation sign */
	if (axl_node_have_childs (aux))
		xml_rpc_support_write (" (VortexCtx * _ctx_, ");
	else
		xml_rpc_support_write (" (VortexCtx * _ctx_");

	/* write function parameters */
	xml_rpc_support_write_function_parameters (doc, aux);

	/* terminate header */
	xml_rpc_support_write (")\n{\n");

	/* push the indent */
	xml_rpc_support_push_indent ();

	xml_rpc_support_write ("XmlRpcMethodCall * _invocator_;\n\n");
	xml_rpc_support_write ("/* create the method call invocator */\n");
	
	
	/* check there is a method call defined (alternative method
	 * call name) */
	aux2 = axl_node_get_child_called (node, "method_name");
	
	if (aux2 == NULL) {
		xml_rpc_support_write ("_invocator_ = method_call_new (_ctx_, \"%s\", %d);\n\n", 
				       service_name, axl_node_get_child_num (aux));
	} else {
		/* we have method_name defined */
		method_name = axl_node_get_content_trim (aux2, NULL);
		xml_rpc_support_write ("_invocator_ = method_call_new (_ctx_, \"%s\", %d);\n\n", 
				       method_name, axl_node_get_child_num (aux));
	}
											   


	/* write method create values sentences */
	xml_rpc_support_write_method_create_values (doc, aux, comp_name);
	
	xml_rpc_support_multiple_write ("/* return invocator created */\n",
					"return _invocator_;\n",
					NULL);
	
	/* pop indent */
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	/* write the header body declaration for the sync
	 * implementation */
	xml_rpc_c_stub_write_service_sync (doc, comp_name, node, axl_false);
	
	xml_rpc_support_write ("{\n");

	/* push the indent for the function content */
	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("XmlRpcMethodCall     * _invocator_;\n",
					"XmlRpcMethodResponse * _response_;\n",
					"VortexCtx            * _ctx_ = CHANNEL_CTX(channel);\n\n",
					"/* create the XmlRpcMethodCall object */\n", NULL);

	xml_rpc_support_write ("_invocator_ = __common_%s", service_name);

	/* type prefix */
	xml_rpc_support_write_function_type_prefix (aux);

	if (axl_node_have_childs (aux))
		xml_rpc_support_sl_write (" (_ctx_, ");
	else
		xml_rpc_support_sl_write (" (_ctx_");
	
	/* write function parameters */
	xml_rpc_support_write_function_parameters_names (aux);

	xml_rpc_support_write_sl (");\n\n");

	xml_rpc_support_multiple_write ("/* perform the invocation, in a synchronous way, get blocked\n",
					" * until it is received */\n",
					"_response_ = vortex_xml_rpc_invoke_sync (channel, _invocator_);\n\n",
					NULL);
	xml_rpc_support_write ("/* unmarshall sync result */\n");
	xml_rpc_support_write ("return %s ", xml_rpc_c_stub_write_service_body_sync_unmarshaller (doc, return_type));
	
	if (xml_rpc_c_stub_type_is_array (doc, return_type))
		xml_rpc_support_sl_write (" (_response_, (XmlRpcArrayUnMarshaller) %s_%s_unmarshall, status, channel, fault_code, fault_string);\n",
					  comp_name_lower, return_type_lower);
	else if (xml_rpc_c_stub_type_is_struct (doc, return_type))
		xml_rpc_support_sl_write (" (_response_, (XmlRpcStructUnMarshaller) %s_%s_unmarshall, status, channel, fault_code, fault_string);\n",
					  comp_name_lower, return_type_lower);
	else if (axl_cmp (return_type, "bool"))
		xml_rpc_support_sl_write (" (_response_, status, channel, fault_code, fault_string) == axl_true;\n");
	else
		xml_rpc_support_sl_write (" (_response_, status, channel, fault_code, fault_string);\n");

	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");
	
	/* write the header body declaration for the async
	 * implementation */
	xml_rpc_c_stub_write_service (doc, comp_name, node, axl_false);
	/* push the indent for the function content */
	xml_rpc_support_push_indent ();

	xml_rpc_support_multiple_write ("XmlRpcMethodCall     * _invocator_;\n",
					"VortexCtx            * _ctx_ = CHANNEL_CTX(channel);\n\n",
					"/* create the XmlRpcMethodCall object */\n", NULL);

	xml_rpc_support_write ("_invocator_ = __common_%s", service_name);

	/* type prefix */
	xml_rpc_support_write_function_type_prefix (aux);

	if (axl_node_have_childs (aux))
		xml_rpc_support_sl_write (" (_ctx_, ");
	else
		xml_rpc_support_sl_write (" (_ctx_");
	
	/* write function parameters */
	xml_rpc_support_write_function_parameters_names (aux);

	xml_rpc_support_sl_write (");\n\n");

	xml_rpc_support_multiple_write ("/* perform invocation, passing an unmarshall function that\n",
					" * receives the int value and the handler from the user\n",
					" * space */\n", NULL);

	xml_rpc_support_write (" vortex_xml_rpc_invoke (channel, _invocator_, %s, process);\n\n",
			       xml_rpc_c_stub_write_service_body_async_unmarshaller (doc, return_type));
	
	xml_rpc_support_multiple_write ("/* nothing more to do: the invocator and values added are not\n",
					" * required to be released because they are deallocated by the\n",
					" * invocator engine. */\n",
					"return;\n",
					NULL);

	/* pop current indent */
	xml_rpc_support_pop_indent ();

	xml_rpc_support_write ("}\n\n");

	/* release memory used */
	axl_free (comp_name_lower);
	axl_free (return_type_lower);

	return;
}

/** 
 * @internal
 * 
 * Writes the XML-RPC body file.
 * 
 * @param doc The document containing the XML-RPC file.
 *
 * @param result A reference to the path where the body file should be
 * created.
 *
 * @param comp_name The XML-RPC component name.
 */
void xml_rpc_c_stub_create_body_file (axlDoc * doc, char  * result, char  * comp_name)
{
	axlNode * node;
	char    * comp_name_lower;

	/* get lower version */
	comp_name_lower   = xml_rpc_support_to_lower (comp_name);

	/* open the header stub */
	xml_rpc_support_open_file ("%s/%s_xml_rpc.c", result, comp_name_lower);

	/* write header */
	xml_rpc_source_write_header (comp_name);

	xml_rpc_support_write ("#include <%s_xml_rpc.h>\n\n",
			       comp_name_lower);

	/* open the xml rpc interface, get the first node, inside the
	 * interface: <name> */
	node = axl_doc_get (doc, "/xml-rpc-interface/name");

	
	/* foreach top level node inside the xml-rpc interface */
	while ((node = axl_node_get_next (node)) != NULL) {

		/* check for the service case */
		if (axl_cmp (axl_node_get_name (node), "service")) {
			xml_rpc_c_stub_write_service_body (doc, comp_name, node);
		}
	}
	
	
	/* close the file */
	xml_rpc_support_close_file ();

	axl_free (comp_name_lower);

	/* header created */
	return;
}

/** 
 * @internal
 * 
 * Produces the C client stub, according to the data received at the
 * \ref axlDoc reference. 
 */
axl_bool      xml_rpc_c_stub_create (axlDoc * doc, 
				     char   * out_dir, 
				     char   * comp_name)
{
	char    * result;
	
	if (exarg_is_defined ("out-stub-dir")) {
		/* get configured out dir */
		out_dir = exarg_get_string ("out-stub-dir");
		xml_rpc_report ("using '%s' as out directory..", out_dir);

		/* create the directory */
		result = xml_rpc_support_create_dir ("%s", out_dir);

	} else {
		xml_rpc_report ("using '%s' as out directory..", out_dir);
		/* create the directory */
		result = xml_rpc_support_create_dir ("%s/client-%s", out_dir, comp_name);
	}

	xml_rpc_report ("generating client stub at: %s..", result);

	/* write the XML-RPC header file */
	xml_rpc_c_stub_create_header_file (doc, result, comp_name);

	/* write the XML-RPC body file */
	xml_rpc_c_stub_create_body_file (doc, result, comp_name);

	/* stub created */
	axl_free (result);


	return axl_true;
}


